%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% partI/chapter1/chapter1.tex
%
% Copyright 2012, Jeffrey Hellrung.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Crack Propagation in Two Dimensions} \label{chap:partI.crackpropagation}

\section{Background and Existing Methods}

\footnote{The content of this chapter is largely a revision of \cite{Richardson11}.}
Since our discretization is essentially an \emph{eXtended Finite Element Method} (XFEM), we summarize the main idea and historical background of the XFEM; see \cite{Belytschko09}, \cite{Karihaloo03}, and \cite{Abdelaziz08} for more complete surveys. The idea is to enrich the usual finite element spaces with additional degrees of freedom, which incorporate the near-tip asymptotic solutions and allow the displacements to be discontinuous across the crack surface. The application of XFEM to cracks began with Belytschko and Black \cite{Belytschko99}, where they applied the partition of unity methods (see, e.g.,\cite{Melenk96}) to the problem of using finite elements with discontinuous basis functions. In \cite{Moes99} Moes et al. used XFEM to create a technique for simulating crack propagation in two dimensions without remeshing the domain. Sukumar et al. \cite{Sukumar00} began the extension to three dimensions. They used the two dimensional enrichment functions for planar cracks, and then further extended in \cite{Areias05}.

Since its introduction, XFEM enrichment has been employed in a variety of settings to model fracture. Moes and Belytschko \cite{Moes02b} modelled cohesive fracture using special enrichments, and this was extended in \cite{Zi.Goangseup03} and continues to be developed (see, e.g., \cite{Mariani03, Borst04, Asferg07}). Work in other settings includes fracture with elastodynamics \cite{Belytschko04} and crack propagation in composite materials \cite{Huynh09}. The XFEM has been combined naturally with the level set methods of Osher and Sethian \cite{Osher88, Osher04} to track the moving discontinuity sets (for cracks see, e.g., \cite{Belytschko01, Moes02a, Gravouil02, Duflot07, Prabel07}; and for holes and inclusions see \cite{Sukumar01}); Sukumar et al. \cite{Sukumar08} coupled the XFEM with fast marching methods. Bordas et al. \cite{Bordas07} studied error estimates, and various techniques have increased the rate of convergence, such as cut off functions and geometric enrichment \cite{Chahine06, Chahine08, Shen09}. However, the XFEM approach still carries a couple technical challenges: assembling the stiffness matrix requires integration of singular or discontinuous functions and implementing enrichment requires resolving material connectivity (often using a level set representation).

Quadrature for integration of the gradients of the XFEM basis functions is an active area of research because of the singularities and discontinuities present. As noted in \cite{Daux00}, the use of Gaussian quadrature or Monte Carlo integration is unstable: since the crack geometry within a given triangle is unknown a priori, quadrature points could be very close to singularities in the integrand. One approach to the problem (see, e.g., \cite{Stazi03}) is to perform a Delaunay triangulation on the cut triangle that respects the crack geometry and then use Gaussian quadrature on each of the resulting triangles. This triangulation does not produce additional degrees of freedom; it is only used for integration of the basis functions. Other methods, e.g., \cite{Bechet05, Laborde05}, map the near-tip enrichment functions to domains amenable to Gaussian quadrature, but also require meshing of the tip triangle. Another approach is to use higher order Gaussian quadrature \cite{Strouboulis00}. In \cite{Ventura09}, Ventura et al. transformed the area integral required for assembly of the stiffness matrix into a more stable line integral. Park et al. \cite{Park09} also used a mapping technique to remove the singularity for tetrahedral elements (in three dimensions), while Areias and Belytschko \cite{Areias05} used a smoothing technique. For integrating the Heaviside functions, Ventura \cite{Ventura06} used a map to equivalent polynomials which were integrated using standard quadrature techniques; Holdych et al. \cite{Holdych08} used a similar technique where they introduced a dependence of the Gaussian quadrature weights on the position of the quadrature point within the triangle. Benvenuti et al. \cite{Benvenuti08} regularized the Heaviside function for integration with Gauss quadrature and proved that the solutions converge as the regularization parameter goes to zero. Mousavi and Sukumar \cite{Mousavi10} used a quadrature rule that avoids Delaunay triangulation and does not require splitting cut elements for Heaviside enrichment. 

We introduce a simple method of integration (see \S\ref{sec:chap1.integration}) that combines naturally with the mesh cutting algorithm (see \S\ref{sec:chap1.cutting}). Our scheme involves creating a finer mesh for integration purposes only. This is similar to the approach of Ji et al. \cite{Ji.H02} and Dolbow \cite{Dolbow99}; however, we resolve the crack surface inside the quadrature elements and use an approximation of the nonlinear basis functions for the purposes of quadrature. Mousavi et al. \cite{Mousavi11} also use modified enrichment functions; however, they compute new enrichment functions by solving a partial differential equation, whereas we simply project the usual enrichment functions onto a simpler finite element space. Also in \cite{Mousavi11}, the authors solve for and integrate their enrichment functions on a mesh that is refined near the tip; since we also use such a mesh, it may be possible to incorporate their idea of computing the enrichment functions into our approach.

In order to allow cracks to open, XFEM needs to generate additional degrees of freedom, generally referred to as \emph{enrichment}. In a region that has been unambiguously separated into two pieces (i.e., away from the crack tip), the enrichment is provided by a Heaviside function, defined to be $+1$ on one side of the crack surface and $-1$ on the other side. This is easy in the case of a single straight crack but more challenging as the crack geometry becomes complicated. Daux et al. \cite{Daux00} handle the case of branched cracks by using separate enrichments for each crack, and then use another enrichment function to represent the junction itself. They then generalize this technique to cracks that have multiple branches; however, their method requires that the cracks have been hierarchically decomposed into a main crack and its branched components, and it still involves solving the problem of material connectivity. Budyn et al. \cite{Budyn04} and Zi et al. \cite{Zi.G04} extend \cite{Daux00} to incorporate multiple cracks and to address the issue of intersecting cracks. Song and Belytschko \cite{Song09a} introduced the cracking node method, which is based on XFEM and is designed to more easily handle complicated crack geometries.

The use of phantom, ghost, or virtual nodes (e.g., \cite{Molino05}) to incorporate discontinuities has become increasingly popular. The methods of Hansbo and Hansbo \cite{Hansbo04}, Song et al. \cite{Song06}, and Duan et al. \cite{Duan09} (which are equivalent; see \cite{Areias06}) use a notion of ghost or phantom degrees of freedom to handle displacement discontinuities. Song and Belytschko also use a phantom node method in \cite{Song09b}, where they additionally use the product of multiple Heaviside functions to handle branched cracks. Dolbow and Harari \cite{Dolbow09} use phantom nodes in the context of embedded interface problems. We likewise use virtual nodes by leveraging the mesh cutting algorithm in \cite{Sifakis07}, making it possible to handle complex crack geometry (such as branching) systematically. Also, our method can create different finite element spaces than the methods presented in \cite{Hansbo04} or \cite{Song06} (see \S\ref{sec:chap1.integration}).

We present a method for simulating quasistatic crack propagation in $2$ dimensions which combines the XFEM with a simple integration procedure and a the geometrically flexible mesh cutting algorithm described in \cite{Sifakis07}. To summarize, our approach

\begin{itemize}
\item is based on virtual nodes created by the mesh cutting algorithm that incorporates material connectivity,
\item can handle complicated crack patterns (including multiple tips in the same element, branching, and tips within fully cut elements),
\item can handle geometrically complex domains,
\item does not require remeshing of the domain (which is entirely in the spirit of XFEM),
\item employs a quadrature rule that again utilizes the mesh cutting algorithm, and whose degree of complexity is independent of the crack geometry.
\end{itemize}

\setlength{\figurewidth}{0.79\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/crack2}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/crack1}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/stress}
\caption{An example with a complex branching crack. (top) A crack surface cutting the simulation mesh; (center) the crack surface cutting the embedded quadrature mesh; (bottom) the computed stress field with uniform traction applied to the left and right edges.}
\label{fig:chap1.introexample}
\end{figure}

\section{Governing Equations}

We assume quasistatic evolution, such that at each fixed point in time the material is in elastic equalibrium. Denoting the rest configuration by $\Omega \subset \bbR^2$ open and bounded, we thus consider the equations of elastic equilibrium given by
\begin{align*}
\nabla \cdot \bssigma + \bfb & = \bfzero \quad \in \Omega \setminus \Gamma; \\
\bfu & = \bfu_0 \quad \in \dOmega_d; \\
\bssigma \cdot \hatn & = \bfg \quad \in \dOmega_n; \\
\bssigma \cdot \hatn & = \bfzero \quad \in \Gamma^+; \\
\bssigma \cdot \hatn & = \bfzero \quad \in \Gamma^-;
\end{align*}
where $\bssigma$ is the Cauchy stress tensor; $\bfb$ is the body force per unit volume; $\bfu$ is the (unknown) displacement; $\bfu_0$ is the Dirichlet boundary condition (applied to a subset of the boundary $\dOmega_d$); $\bfg$ is the traction (Neumann) boundary condition (applied to $\dOmega_n$); $\hatn$ denotes the unit outward-pointing normal; $\Gamma$ is the crack surface; and $\Gamma^+, \Gamma^-$ represent the two opposite orientations of the crack surface. In the present exposition, we consider the case of small strains and displacements, where linear elasticity is an accurate model of material behavior. Hence we use the Cauchy strain
\begin{equation*}
\bsepsilon(\bfu) := \nabla_S \bfu := \frac{1}{2} \lrp{\nabla \bfu + (\nabla \bfu)^t}
\end{equation*}
and stress
\begin{equation*}
\bssigma := \bfC : \bsepsilon
\end{equation*}
where $\bfC$ is the Hooke tensor. Equivalently, one may consider minimizing over $\bfu$ the potential energy
\begin{equation} \label{eq:chap1.energy}
\Psi[\bfu] := \frac{1}{2} \int_{\Omega} \bsepsilon(\bfu) : \bfC : \bsepsilon(\bfu) d\bfx - \int_{\Omega} \bfb \cdot \bfu d\bfx - \int_{\dOmega_n} \bfg \cdot \bfu d\bfS(\bfx)
\end{equation}
subject to $\bfu = \bfu_0$ on $\dOmega_d$.

\section{Extended Finite Elements} \label{sec:chap1.xfem}

Conceptually, the starting point of our work is the eXtended Finite Element Method \linebreak[4] (XFEM), which was originally motivated and studied in the context of fracture by Belytschko et al.; see, e.g., \cite{Moes99}. In the original XFEM, a simulation with quasistatics evolution requires one to solve a discrete approximation to the equations of elastic equilibrium at each time step. The approximation subspace is formed by taking the usual $C_0$ conforming finite element space (in our case, on triangles) and \emph{enriching} with additional degrees of freedom that allow cracks to open and increase the accuracy of the approximation near the crack tip. Thus, functions in an XFEM space $\calU^h$  have the form
\begin{equation} \label{eq:chap1.xfem}
\bfu^h(\bfx) = \sum_i \bfu_i \phi_i(\bfx) + \sum_j \bfb_j \phi_j(\bfx) H(\bfx) + \sum_k \phi_k(\bfx) \sum_{\ell = 1}^4 \bfc_k^{\ell} F_{\ell} \lrp{r(\bfx), \theta(\bfx)},
\end{equation}
where $\{\phi_i\}$ are the usual nodal basis functions; $H(\bfx)$ is the Heaviside function associated to the current crack geometry; $\{\bfb_j\}$ are enrichment degrees of freedom associated with crack separation away from the crack tip; $ \{\bfc_k^\ell\}$ are enrichment degrees of freedom associated with near-tip displacement; and
\begin{equation*}
\set{F_{\ell}(r,\theta)} := \set{ \sqrt{r} \sin \frac{\theta}{2}, \sqrt{r} \cos \frac{\theta}{2}, \sqrt{r} \sin \frac{\theta}{2} \sin \theta, \sqrt{4} \cos \frac{\theta}{2} \sin \theta }
\end{equation*}
are the asymptotic near-tip enrichment functions ($r$ and $\theta$ are the polar coordinates with respect to the crack tip). Notice that \eqref{eq:chap1.xfem} expresses $\bfu^h$ as a linear combination of three types of basis functions: the usual nodal basis functions (which have support local to mesh vertices), Heaviside enrichment functions, and near-tip enrichment functions (which have support local to the crack tip). The sum over $i$ in \eqref{eq:chap1.xfem} is over all mesh vertices, while the sums over $j$ and $k$ are over those vertices whose corresponding conforming basis functions have support that intersects the crack surface (see \cite{Moes99}). We use the term \emph{one-ring} of a vertex to refer to the set of elements composing the support of the corresponding nodal basis function. Strictly speaking, \eqref{eq:chap1.xfem} only accounts for a single crack tip, but it may be generalized to accomodate crack geometries with multiple tips.

\section{Cutting of Cracked Domains} \label{sec:chap1.cutting}

To simplify the exposition, we first focus on the discretization away from any crack tips (thus ignoring tip enrichment) where \eqref{eq:chap1.xfem} takes the simpler form
\begin{equation*}
\bfu^h(\bfx) = \sum_i \bfu_i \phi_i(\bfx) + \sum_{j \in J} \bfb_j \phi_j(\bfx) H(\bfx),
\end{equation*}
where $J$ is the set of vertices whose one-ring intersects the crack surface. We begin by replacing these more traditional Heaviside-enriched degrees of freedom with more geometrically intuitive virtual nodes (see \cite{Molino05}), also known as ghost or phantom nodes (see, e.g., \cite{Song06}, \cite{Hansbo04}, \cite{Dolbow09}). As discussed in the prelude to Part I, these virtual nodes are automatically created by the mesh cutting algorithm of Sifakis et al. \cite{Sifakis07}. Figures~\ref{fig:chap1.cutting.unrefined} and \ref{fig:chap1.cutting.refined} illustrate an example of the mesh cutting algorithm more closely related to our present application. In Figure~\ref{fig:chap1.cutting.unrefined}, we introduce a crack which completely cuts one triangle and only partially cuts another. In Figure~\ref{fig:chap1.cutting.refined}, we introduce the same crack into a locally refined mesh. In the present context, the unrefined mesh corresponds to the simulation mesh, while the refined mesh -- after being cut as in the example -- corresponds to the quadrature mesh (see \S\ref{sec:chap1.integration}).

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/cutting2}
\caption{A crack is introduced into the mesh on the left, yielding the enriched mesh on the right, with duplicated triangles and virtual nodes, which we use as our simulation mesh.}
\label{fig:chap1.cutting.unrefined}
\end{figure}

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/cutting3}
\caption{For quadrature purposes, we refine the uncut mesh in Figure~\ref{fig:chap1.cutting.unrefined}(left) around the cut (upper left), then cut this refined mesh (bottom). A blow up of the region near the crack (upper right) shows the virtual nodes relative to the crack surface.}
\label{fig:chap1.cutting.refined}
\end{figure}

Now, consider a mesh that has been cut, with the associated duplication of elements and introduction of virtual nodes. Corresponding to each virtual node, we create a nodal basis function that respects the crack geometry, i.e., we take into account that vertices and triangles may have been duplicated (see Figure~\ref{fig:chap1.truncatedbasis} for a one-dimensional illustration). Let $\{\tilde{\phi}_i\}$ be the usual piecewise affine nodal basis ``hat'' functions on the simulation mesh, and let $\bfx_i$ be the vertex (which may be a virtual node) corresponding to a given $\tilde{\phi}_i$. Denote by $\Omega_i$ the collection of triangles in the one-ring of vertex $\bfx_i$. Given the preceding notation, we define a new \emph{truncated} hat function $\phi_i$ via
\begin{equation} \label{eq:chap1.truncatedbasis}
\phi_i(\bfx) := \tilde{\phi}_i(\bfx) \sum_{T \in \omega_i} \chi_T^M(\bfx),
\end{equation}
where $\chi_T^M$ is the characteristic function of the material region of triangle $T$.

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/truncated_basis}
\caption{A truncated basis function in dimension $1$. At left, a mesh element with vertices $1$ and $2$ is cut by the red dot, resulting in the two duplicate elements on the right. The original nodal basis ``hat'' function $\tilde{\phi}_2$ corresponding to vertex $2$ (green) gets truncated into derived basis functions $\phi_2$ and $\phi_4$ according the material region within each duplicate element.}
\label{fig:chap1.truncatedbasis}
\end{figure}

In many cases, this virtual node approach is equivalent to the more traditional use of Heaviside enrichment as well as the methods of Song et al. \cite{Song06} and Hansbo and Hansbo \cite{Hansbo04}, i.e., they give equivalent finite element spaces. However, certain crack geometries do, in fact, yield different spaces. As an example, the configuration in Figure~\ref{fig:chap1.triplecut}(left) is cut by a crack given by the red line. The resulting finite element spaces differ between the two methods. Heaviside enrichment and the methods of Song et al. \cite{Song06} and Hansbo and Hansbo \cite{Hansbo04} yield the degrees of freedom depicted in Figure~\ref{fig:chap1.triplecut}(center), while the mesh cutting algorithm from \cite{Sifakis07} yields the degrees of freedom depicted in Figure~\ref{fig:chap1.triplecut}. Since the material region of the top triangle to the right of the crack surface is not materially connected to the bottom triangle, the bottom left virtual nodes are allowed to separate (see top-right of Figure~\ref{fig:chap1.triplecut}). Generally speaking, the finite element spaces resulting from the mesh cutting algorithm are at least as rich as the spaces resulting from Heaviside enrichment, and in some situations it may in fact be strictly richer (i.e., have strictly larger dimension).

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/triple_cut}
\caption{Given the uncut mesh and crack at left, XFEM using traditional Heaviside enrichment yields $8 \times 2$ degrees of freedom (center), while using virtual nodes as described in \S\ref{sec:chap1.cutting} yields $9 \times 2$ degrees of freedom (right).}
\label{fig:chap1.triplecut}
\end{figure}

Finally, we note that Sifakis et al. \cite{Sifakis07}, in their presentation of the mesh cutting algorithm, make the simplifying assumption that the cutting surface never coincides with a mesh vertex or aligns with an element face. Nevertheless, the virtual node algorithm is perfectly compatible with such degenerate cases, and this simplifying hypothesis is made only to ease certain implementation challenges related to the representation of the crack surface as an explicit simplex mesh. In fact, the mesh cutting algorithm can accommodate any cut configuration, including these degenerate cases, as long as the following two queries can be algorithmically determined: (a) the number of disjoints fragments a given element is divided into; and (b) material connectivity of element fragments originating from face-adjacent elements.

For example, if the crack surface is instead represented implicitly as the zero isocontour of a level set function sampled at the vertices of the simulation mesh (or a refinement thereof), both of the above queries admit a straightforward algorithm determination, and hence the element duplication and joining algorithm described in \cite{Sifakis07} may be applied, even when the zero isocontour coincides with a mesh vertex. In the present case, with the crack surface represented explicitly as a simplex mesh (segmented curve in $2$ dimensions or triangulated surface in $3$ dimensions), the robust determination of (a) and (b) is challenging given the limited precision of typical floating point arithmetic. Rather than complicate the implementation to address degenerate or near-degenerate scenarios, we found it preferable and practical to avoid these scenarios entirely by simply perturbing the crack surface negligibly. Naturally, if we use a level set representation, no such perturbation is necessary.

\section{Integration} \label{sec:chap1.integration}

Our integration scheme utilizes a subordinate quadrature mesh in addition to the primary simulation mesh, the details of which we describe here. For simplicity, we assume a domain-conforming triangulation, creating a mesh corresponding to Figure~\ref{fig:chap1.cutting.unrefined}(left). We then construct a pair of derived meshes:
\begin{itemize}
\item We apply the mesh cutting algorithm to resolve the crack surface against the original mesh, yielding the \emph{simulation mesh}, corresponding to Figure~\ref{fig:chap1.cutting.unrefined}(right). The simulation mesh contains the actual simulation degrees of freedom, include both virtual and crack tip enrichment degrees of freedom.
\item We also locally refine the original mesh around the crack and resolve the crack against this refined mesh, yielding the \emph{quadrature mesh}, corresponding to Figure~\ref{fig:chap1.cutting.refined}(right). The quadrature mesh only possesses nodal degrees of freedom (i.e., no crack tip enrichment degrees of freedom), and these degrees of freedom are subordinate to the interpolated values from the simulation mesh. We only use the quadrature mesh to aid in the integrations involving the enrichment functions on the simulation mesh, and it does not add additional degrees of freedom to the system.
\end{itemize}
We solve the equilibrium equations of linear elasticity on the relatively coarse simulation mesh (with fewer degrees of freedom), but perform the requisite integrations on the relatively fine quadrature mesh by approximating the (generally nonlinear) basis functions over the simulation mesh with piecewise affine projections over the quadrature mesh. We then use a composite one-point quadrature rule over the quadrature mesh.

Our integration scheme is similar to another scheme presented in the XFEM literature (e.g., \cite{Stazi03}). The main idea is to compute a Delaunay triangulation respecting the crack geometry within each simulation triangle and assembling the stiffness matrix by applying Gaussian quadrature over each Delaunay triangle. Hence, like our scheme, this employs a finer triangulation of the original mesh solely for integration purposes and does not add degrees of freedom to the simulation. However, our integration scheme uses the mesh cutting algorithm \cite{Sifakis07} to resolve the crack geometry within the quadrature mesh (see, e.g., Figure~\ref{fig:chap1.introexample}(center)), and so, in contrast to Delaunay triangulation, the quadrature mesh will only approximately conform to the crack geometry. This has the advantage of decoupling the resolution of the quadrature mesh from the resolution of the crack surface. Further, this use of the mesh cutting algorithm naturally extends to higher dimensions, where Delaunay tessellations become significantly more challenging.

\subsection{Construction of the Simulation Mesh and Quadrature Mesh}

We now describe the construction of our key meshes in more detail, and we will use notation consistent with \cite{Braess07}. We construct the simulation mesh as described in \S\ref{sec:chap1.cutting}. Using the modified hat functions from \eqref{eq:chap1.truncatedbasis}, we define our (simulation) finite element space $\bfV^h$ as those vector-valued functions $\bfu^h$ of the form
\begin{equation} \label{eq:chap1.xfem2}
\bfu^h(\bfx) = \sum_i \bfu_i \phi_i(\bfx) + \sum_k \phi_k(\bfx) \sum_{\ell = 1}^4 \bfc_k^{\ell} F_{\ell} \lrp{r(\bfx), \theta(\bfx)}
\end{equation}
where $\{F_{\ell}\}$ are the asymptotic near-tip enrichment functions given in \S\ref{sec:chap1.xfem}. The difference between \eqref{eq:chap1.xfem2} and \eqref{eq:chap1.xfem} is that \eqref{eq:chap1.xfem2} already incorporates the Heaviside enrichment (the sum over $j$ in \eqref{eq:chap1.xfem}) via the introduction of virtual nodes and the truncated basis functions. We let $F^h := \{\bfu_i, \bfc_k^{\ell}\}$ denote the degrees of freedom of $\bfV^h$ and identify $F^h$ with $\bbR^N$, where $N$ is the number of degrees of freedom in the simulation.

We now discuss the construction of the quadrature mesh. We begin by regularly refining triangles in the original mesh that intersect the crack surface. This refinement is progressively graded as the distance from the crack increases via red-green refinement \cite{Molino03}. We resolve the crack surface against this refined mesh via the mesh cutting algorithm to yield the quadrature mesh; this ensures the quadrature mesh will respect the crack topology (see Figure~\ref{fig:chap1.cutting.refined}). We then define a quadrature finite element space $\bfV_q^h$ to be the piecewise affine finite element space over this quadrature mesh, i.e., $\bfu_q^h \in \bfV_q^h$ takes the form
\begin{equation} \label{eq:chap1.xfem.refined}
\bfu_q^h(\bfx) = \sum_i \bfu^q_i \phi^q_i(\bfx)
\end{equation}
where $\{\phi^q_i\}$ are the associated truncated nodal basis functions (as in \eqref{eq:chap1.truncatedbasis}). We let $F_q^h := \{\bfu^q_i\}$ denote the degrees of freedom of $\bfV_q^h$ and identify $F_q^h$ with $\bbR^M$, where $M$ is twice the number of vertices in the quadrature mesh. Since we do not employ the asymptotic near-tip enrichment functions in the quadrature finite element space (as we do for the simulation finite element space), all the degrees of freedom $F_q^h$ can be identified with a vertex in the quadrature mesh and a coordinate direction.

We use the quadrature mesh and associated finite element space to approximate the integrals of the gradients of the $\bfV^h$-basis functions. To this end, we subordinate the quadrature mesh to the simulation mesh via a fixed linear relationship between $F_q^h$ and $F^h$ (see \cite{Sifakis07b}). Consider $\bfu^q_i \in F_q^h$ and the position of its corresponding mesh node $\bfx^q_i$. We express $\bfu^q_i$ in terms of the simulation degrees of freedom $F^h$ using \eqref{eq:chap1.xfem2}:
\begin{equation} \label{eq:chap1.binding}
\bfu^q_i = \sum_j \bfu_j \phi_j(\bfx^q_i) + \sum_k \phi_k(\bfx^q_i) \sum_{\ell = 1}^4 \bfc_k^{\ell} F_{\ell} \lrp{r(\bfx^q_i), \theta(\bfx^q_i)}.
\end{equation}
Note that the sume over $j$ involves at most $3$ nonzero terms as $\bfx^q_i$ can be in the support of at most three of the $\phi_j$'s. According to \eqref{eq:chap1.binding}, the quadrature degrees of freedom $\bfu^q_i$ are functionally constrained to the simulation degrees of freedom $\{\bfu_i, \bfc_k^{\ell}\}$ and hence do not introduce any new degrees of freedom. This effectively defines a linear relationship between the quadrature and simulation degrees of freedom which we denote by the matrix $W$ (see below). Binding the quadrature mesh to the simulation mesh in this fashion allows us to project the basis functions of $\bfV^h$ onto $\bfV_q^h$ and operate on these projections in the piecewise affine quadrature finite element space, where the integration is simpler.

Special care must be taken when computing the polar coordinates $(r(\bfx^q_i), \theta(\bfx^q_i))$ of $\bfx^q_i$ when it corresponds to a virtual node. As illustrated in Figure~\ref{fig:chap1.binding.virtual}, for virtual nodes, we must reverse the orientation of the angle $\theta$ with respect to the crack, allowing it to take values outside the typical $[-\pi,+\pi]$ bounds. We effectively associate a virtual node with the opposite side of the crack surface, where the material region associate with the virtual node resides. This ensures that $\theta(\bfx)$ is continuous throughout the triangle.

\setlength{\figurewidth}{0.50\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/bind_virtual}
\caption{The polar angle of a virtual node in the quadrature mesh is measured across the crack surface to ensure continuity of $\theta$ throughout a quadrature triangle.}
\label{fig:chap1.binding.virtual}
\end{figure}

\subsection{Integration Scheme}

The relation \eqref{eq:chap1.binding} binds the quadrature degrees of freedom $F_q^h$ to the simulation degrees of freedom $F^h$. Letting $\vec{u} \in F^h$ and $\vec{u}^q \in F_q^h$, we can encode the coefficients of \eqref{eq:chap1.binding} in a matrix $W$, such that $\vec{u}^q = W \vec{u}$. Let $A$ and $A^q$ denote the stiffness matrices associated with the energy \eqref{eq:chap1.energy} discretized over the finite element spaces $\bfV^h$ and $\bfV_q^h$, respectively; and let $\alpha$ denote the bilinear form associated with \eqref{eq:chap1.energy}. Since $\bfV_q^h$ is a piecewise affine finite element space, there is a natural and standard procedure to assemble its stiffness matrix $A^q$. Our integration scheme then approximates the true stiffness matrix $A$ via
\begin{equation} \label{eq:chap1.Atransform}
\vec{u}^t A \vec{u} = \alpha(\bfu^h, \bfu^h) \approx \alpha(\bfu_q^h, \bfu_q^h) = (\vec{u}^q)^t A^q \vec{u}^q = \vec{u}^t W^t A^q W \vec{u},
\end{equation}
where $\bfu^h$ ($\bfu_q^h$) is the function in $\bfV^h$ ($\bfV_q^h$) corresponding to the vector $\vec{u} \in F^h$ ($\vec{u}^q \in F_q^h$). It follows that $A \approx W^t A^q W$.

Ultimately, our integration scheme utilizes an approximation (indeed, a projection) of the non-smooth basis functions (see Figure~\ref{fig:chap1.sampling}), with this approximation improving as one further refines the quadrature mesh. Note that we may end up sampling a singular basis function near the singularity. However, unlike integration schemes based on Gaussian quadrature or Monte Carlo methods, any function evaluations at these sampling points will be weighted by the area of the smaller quadrature triangle. Thus, no single sample, possibly located near the tip singularity, contributes disproportionally. Finally, we note that for simplicity and improved stability, we can further approximate the integrations implicit in \eqref{eq:chap1.Atransform} by treating cut quadrature triangles as if they were full of material, i.e., removing the characteristic function multiplications in \eqref{eq:chap1.truncatedbasis} and assembling $A^q$ over the usual nodal basis ``hat'' functions. This optional modification vanishes under refinement of the quadrature mesh, as the error caused by the additional basis function support goes to zero. In \S\ref{sec:chap1.examples}, our examples account for the material region in cut quadrature triangles. We additionally present some comparisons between treating quadrature triangles as completely full and respecting the actual material regions.

\setlength{\figurewidth}{0.50\textwidth}
\begin{figure}[htbp]
\centering
\subfloat[]
{\includegraphics[width=\figurewidth]{partI/chapter1/figures/lowres}}
\subfloat[]
{\includegraphics[width=\figurewidth]{partI/chapter1/figures/highres}}
\caption{Two samplings of the asymptotic near-tip enrichment function $F_1 = \sqrt{r} \sin \frac{\theta}{2}$. (a) shows a sampling at a low resolution, while (b) shows a sampling at a high resolution.}
\label{fig:chap1.sampling}
\end{figure}

\section{Crack Propagation} \label{sec:chap1.propagation}

For a fixed state of the system, i.e., a given crack and an equilibrium displacement for that crack and boundary conditions, there are several different criteria used by engineers to determine the angle at which the crack will propagate. We follow \cite{Moes99} in using the maximum circumferential stress criterion to compute the propagation direction and then move the crack by a small fixed increment. We chose this approach so that the results of using our integration technique can be compared against the tests cases in \cite{Moes99}. This method is fairly standard and the details are found in the references, so we only sketch it here.

\begin{comment}

The criterion involves computing the stress intensity factors at the crack tip, and then calculating the angle of maximal stress
by the relation:
\begin{eqnarray}
	\theta_c = 2 \arctan \left( \frac{1}{4} \left[ \frac{K_\text{I}}{K_{\text{II}}}\pm \sqrt{ \left( \frac{K_\text{I}}{K_{\text{II}}} \right)^2 + 8} \right] \right).
\end{eqnarray}
To compute the stress intensity factors, we use the so called interaction J-integral, which is defined for two possible states of the system, whose variables we denote using superscript 1 and 2, by:
\begin{eqnarray}
\label{eq:contour_interaction_integral}
	I^{(1,2)} := \int_{\Gamma} \left( W^{(1,2)} \delta_{1j} - \Big[ \sigma_{ij}^{(1)} \frac{\partial u_i^{(2)}}{\partial x_1} + \sigma_{ij}^{(2)} \frac{\partial u_i^{(1)}}{\partial x_1} \Big] \right) n_j ds
\end{eqnarray}
where
\begin{eqnarray}
	W^{(1,2)} & := & \sigma_{ij}^{(1)} \epsilon_{ij}^{(2)}.
\end{eqnarray}
Choosing the two states to be the current state and a pure Mode I state in the above gives $K_\text{I}$:
\begin{eqnarray}
	 K_{\text{I}} &=& \frac{E^*}{2}I^{(\text{Curr},\text{Mode I})},
\end{eqnarray}
where
\begin{equation}
	E^* = 
	\left\{
	\begin{aligned}
		&\frac{E}{1 - \nu^2} &\text{plane strain} \\
		&E &\text{plane stress},
	\end{aligned}
	\right.
\end{equation}
and $E$ is Young's modulus and $\nu$ is Poisson's ratio. $K_{\text{II}}$ is found similarly. As in \cite{Moes99}, to actually compute these interaction integrals requires converting them into area intregrals via multiplication by a suitably smooth test function and applying integration by parts.

The resulting area integral is then computed on the embedded quadrature mesh described in Section \ref{sec:chap1.integration}. Having used finite elements to compute the displacement, the stresses and strains for the current state of the system are piecewise affine on the embedded mesh. We then interpolate the displacements, strains, and stresses for the pure Mode I and pure Mode II solutions used to compute \eqref{eq:contour_interaction_integral} using functions in the space $\mathcal{M}_h$. The required integrations are then simple to compute, since all the quantities in \eqref{eq:contour_interaction_integral} are piecewise affine. 


\section{NUMERICAL EXPERIMENTS}
\label{sec:chap1.examples}

We tested our approach with some examples from the literature 
(see \cite{Belytschko99}, \cite{Moes99}). First, we chose these examples because the exact stress intensity factors (or good approximations) can be calculated analytically for comparision, and also we can compare our results to the literature.
As discussed in Section \ref{sec:chap1.integration}, we note that our data was produced by integrating over the material areas of the cut quadrature triangles. For Example 1 below, we also present some comparisions of using the true material areas and treating quadrature triangles as full of material. As in \cite{Moes99}, all of our examples use Young's modulus of $10^5$ and Poisson ratio of $.3$. For our propagation examples, we chose a fracture toughness of $1$.

\subsection{ Example 1: Straight Crack with Pure Mode I Displacement }
The first example involves a straight center crack in a rectangular body with a constant traction applied to part of the boundary of the body, as diagrammed in Figure \ref{fig.example1_setup} (as in \cite{Moes99} we use $L=16$, $W=7$, $a=3.5$, $\epsilon=100$[kpsi] and $\nu=.3$).

\begin{figure}[h]
\begin{center}
	\includegraphics[scale=.7]{figures/example1_setup}
	\caption{\captionsize The setup for the first numerical experiment.}
	\label{fig.example1_setup}
\end{center}
\end{figure}

In this case, the exact Mode I stress intensity factor is given by
\[
K_\text{I} = C \sigma \sqrt{a \pi},
\]
where $C$ is the finite geometry correction factor:
\[
C = 1.12 - 0.231 \left( \frac{a}{W} \right) + 10.55 \left( \frac{a}{W} \right)^2 - 21.72 \left( \frac{a}{W} \right)^3 + 30.39 \left( \frac{a}{W} \right)^4.
\]
We normalize $K_\text{I}$ through an appropriate choice of $\sigma$, and compare our results over various combinations of granularity of the simulation mesh and refinement levels of the quadrature mesh. The results of this study are found in Table \ref{fig.results_ex_a}: each column represents a different resolution for the simulation mesh, and data is presented for different levels of regular refinement near the crack ($0-5$ levels). Note that the computed intensity factors improve as the simulation mesh is refined, as expected, but also we are able to get good results for coarser simulation meshes by refining the quadrature mesh (of course, up to a limit that is determined by the simulation resolution). Also, increasing the refinement levels of the quadrature mesh roughly matches the results for increases in resolution of the simulation mesh, and that accuracy is acheived at less cost since refining the quadrature mesh does not add new degrees of freedom to the system. Figure \ref{fig.convergence_ex_a}, illustrates the results of three convergence studies for this example (one, three, and five levels of quadrature refinement). These plots clearly show first order convergence with refinement of the simulation mesh. Finally, Figures \ref{fig.convergence_cut_nocut} and \ref{fig.diff_cut_nocut} compare the use of the true material areas in the quadrature against treating the quadrature triangles as completely full. First, both of these approaches give linear convergence, with slightly different constants. Second, the difference between those two methods goes to zero under refinement of the quadrature mesh (keeping the simulation mesh at a fixed resolution).

\begin{table}[h]
\tiny
\begin{center}
\begin{tabular}{cc}
      \begin{tabular}{|ccccc|}
              \multicolumn{5}{c}{$K_{\text{I}}$}\\
              \hline
Levels & 64x32 & 128x64 & 256x128 & 512x256 \\ \hline
0 & 7.25207	& 3.02688 & 1.68144 & 1.22950 \\ \hline
1 & 0.87748	& 0.93603 & 0.96710	& 0.98310  \\ \hline
2 & 0.90933	& 0.95357 & 0.97632	& 0.98783 \\ \hline
3 & 0.92324	& 0.96132 & 0.98039	& 0.98991  \\ \hline
4 & 0.93210	& 0.96621 & 0.98296	& 0.99122  \\ \hline
5 & 0.93858 & 0.96979 & 0.98482 & 0.99217  \\ \hline
	\end{tabular}
&
	\begin{tabular}{|ccccc|}
              \multicolumn{5}{c}{$K_{\text{II}}$}\\
              \hline
Levels & 64x32 & 128x64 & 256x128 & 512x256 \\ \hline
0 &17.22220	& 5.78543  & 2.01135 & 0.70673 \\ \hline
1 &-0.00252	&-0.00117  &-0.00068 &-0.00037  \\ \hline
2 & 0.00003 & 0.000004 &-0.00010 &-0.00008  \\ \hline
3 &-0.00210 &-0.00091  &-0.00052 &-0.00028 \\ \hline
4 &-0.00245 &-0.00107  &-0.00059 &-0.00031  \\ \hline
5 &-0.00267 &-0.00117  &-0.00063 &-0.00034 \\ \hline
      \end{tabular}
\end{tabular}
\caption{\captionsize Results for first numerical example; analytical result is $K_{\text{I}}=1$, $K_{\text{II}}=0$.}
\label{fig.results_ex_a}
\end{center}
\end{table}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=.4]{figures/example1_1_i}
\includegraphics[scale=.4]{figures/example1_1_ii}
\includegraphics[scale=.4]{figures/example1_3_i}
\includegraphics[scale=.4]{figures/example1_3_ii}
\includegraphics[scale=.4]{figures/example1_5_i}
\includegraphics[scale=.4]{figures/example1_5_ii}
\end{center}
\caption{\captionsize Plots showing convergence of computed Mode I (\emph{left}) and Mode II (\emph{right}) SIFs for Example 1. Each row shows results for a fixed refinement of the quadrature mesh: the top row is 1 level, middle is 3 levels, bottom is 5 levels. Each plot is log/log of error versus simulation mesh resolution; the slope of the fit line is close to -1 which indicates first order convergence. }
\label{fig.convergence_ex_a}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=.3]{figures/example1_1_i_cutcell}
\includegraphics[scale=.3]{figures/example1_1_ii_cutcell}
\includegraphics[scale=.3]{figures/example1_5_i_cutcell}
\includegraphics[scale=.3]{figures/example1_5_ii_cutcell}
\end{center}
\caption{\captionsize Plots comparing the convergence when using true areas of cut quadrature triangles versus treating cut quadrature triangles as completely full. The data are computed Mode I (\emph{left}) and Mode II (\emph{right}) SIFs for Example 1. Each row shows results for a fixed refinement of the quadrature mesh: the top row is 1 level, bottom is 5 levels. }
\label{fig.convergence_cut_nocut}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=.4]{figures/difference_cutcell_example1_i}
\includegraphics[scale=.4]{figures/difference_cutcell_example1_ii}
\end{center}
\caption{\captionsize Plots illustrating the difference between using true areas of cut quadrature triangles versus treating cut quadrature triangles as completely full. At \textit{left} is the difference between $K_\text{I}$ SIF for Example 1 computed with true areas versus full areas; the abscissa corresponds to the levels of quadrature refinement. On \textit{right} is $K_\text{II}$ SIF. Both are computed on 64x32 simulation mesh, the difference decreases with increased quadrature mesh refinement.  }
\label{fig.diff_cut_nocut}
\end{figure}

\subsection{ Example 2: Straight Crack with Constant Shear Displacement }

The second example involved the same geometry as the first example, namely a straight edge crack, but we applied a zero displacement condition to one end and a constant shear (with respect to the crack frame) to the other end
(see the diagram in Figure \ref{fig.example2_setup}). In this case, the stress intensity factors are known (see \cite{Moes99}): $K_\text{I}=34.0$[psi$\sqrt{\mbox{in}}$] and $K_\text{II}=4.55 [$psi$\sqrt{\mbox{in}}$]. Again, we compared our results when varying the refinement of both the simulation and quadrature meshes, with results summarized in Table \ref{fig.results_ex_b}. We performed the same refinement studies as in Example 1, the results are presented in Figure \ref{fig.convergence_ex_b}.

\begin{figure}[h]
\begin{center}
	\includegraphics[scale=.7]{figures/example2_setup}
	\caption{\captionsize The setup for the second numerical experiment.}
	\label{fig.example2_setup}
\end{center}
\end{figure}


\begin{table}[h]
\tiny
\begin{center}
\begin{tabular}{cc}
      \begin{tabular}{|ccccc|}
              \multicolumn{5}{c}{$K_{\text{I}}$}\\
              \hline
Levels & 64x32 & 128x64 & 256x128 & 512x256 \\ \hline
0 & 27.53640	& 30.42170  & 32.13890 & 33.06540 \\ \hline
1 & 29.62800	& 31.79550 & 32.90860	&  33.47320 \\ \hline
2 & 30.72490	& 32.40350 & 33.22860	&  33.63730 \\ \hline
3 & 31.21530	& 32.67390 & 33.37000	& 33.70950  \\ \hline
4 & 31.51230	& 32.83990 & 33.45720	& 33.75420  \\ \hline
5 & 31.73140	& 32.96180 & 33.52120 & 33.78710  \\ \hline
	\end{tabular}
&
	\begin{tabular}{|ccccc|}
              \multicolumn{5}{c}{$K_{\text{II}}$}\\
              \hline
Levels & 64x32 & 128x64 & 256x128 & 512x256 \\ \hline
0 & 7.81139	& 5.55605 & 4.86779 & 4.64271  \\ \hline
1 & 4.36623	& 4.46139 & 4.49335 & 4.51208 \\ \hline
2 & 4.40807 & 4.49142 & 4.51380 & 4.52418 \\ \hline
3 & 4.34959 & 4.46972 & 4.50476 & 4.52010 \\ \hline
4 & 4.34610 & 4.46936 & 4.50504 & 4.52036 \\ \hline
5 & 4.34312 & 4.46894 & 4.50513 & 4.52048 \\ \hline
      \end{tabular}
\end{tabular}
\caption{\captionsize Results for second numerical example; analytical result is $K_{\text{I}}=34.0$, $K_{\text{II}}=4.55$. Note that most of the benefits of refinement of the quadrature mesh are realized after only two to three levels of refinement (infinite refinement would correspond to exact quadrature during assembly). Each plot is log/log of error versus simulation mesh resolution; the slope of the fit line is close to -1 which indicates first order convergence. }
\label{fig.results_ex_b}
\end{center}
\end{table}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=.4]{figures/example2_1_i}
\includegraphics[scale=.4]{figures/example2_1_ii}
\includegraphics[scale=.4]{figures/example2_3_i}
\includegraphics[scale=.4]{figures/example2_3_ii}
\includegraphics[scale=.4]{figures/example2_5_i}
\includegraphics[scale=.4]{figures/example2_5_ii}
\end{center}
\caption{\captionsize Plots showing convergence of computed Mode I (\emph{left}) and Mode II (\emph{right}) SIFs for Example 2. Each row shows results for a fixed refinement of the quadrature mesh: the top row is 1 level, middle is 3 levels, bottom is 5 levels. }
\label{fig.convergence_ex_b}
\end{figure}

\subsection{ Angled Center Crack with Mixed Mode Displacement }

Following the example in Section 4.3 of \cite{Moes99}, we compute the stress intensity factors for a plate with 
an angled center crack and subjected to a far field constant traction, as pictured in Figure \ref{fig.example3_setup}. The dimensions of the square plate are taken to be $W = 10$[in] and the crack length is set by $a=.5$[in]. Since the crack size is small compared to the dimensions of the plate, the stress intensity factors can be approximated by the intensity factors corresponding to the solution in the entire plane, which are given by
\[
K_{\text{I}} = \sigma \sqrt{\pi a} \cos^2(\beta),
\]
\[
K_{\text{II}} = \sigma \sqrt{\pi a} \sin(\beta)\cos(\beta).
\]

\begin{figure}[h]
\begin{center}
	\includegraphics[scale=.7]{figures/example3_setup}
	\caption{\captionsize The setup for the angled center crack numerical experiment.}
	\label{fig.example3_setup}
\end{center}
\end{figure}

We computed the stress intensity factors as $\beta$ ranges from $0$ to $\pi/2$ in increments of $\pi/20$. We used a simulation mesh with resolution of $64$x$64$ elements, and varied the levels of refinement for the quadrature mesh. We illustrate in Figure \ref{fig.example3_results} the results of a comparison between the ``exact'' $K_{\text{I}}$ and $K_{\text{II}}$ for the various values of $\beta$ (plotted using blue squares and orange diamonds, respectively) and the computed values (yellow triangles for computed $K_{\text{I}}$ and green triangles for $K_{\text{II}}$). On the left of the figure, we plot the results for one level of refinement in the quadrature mesh; on the right of the figure we plot the results for five levels of refinement. While one level of refinement gives decent agreement with the exact values, as we refine the quadrature mesh the agreement with the exact values becomes much stronger (and is comparable to the results of \cite{Moes99}).

\begin{figure}[h]
\begin{center}
	\includegraphics[scale=.7]{figures/angle_64_data}
	\caption{\captionsize Results for angled crack example: The top row compares percentage error in computed $K_\text{I}$ SIF (\emph{left}) and computed $K_\text{II}$ SIF (\emph{right}) for 0 levels of quadrature refinement (\emph{blue squares}) and 5 levels (\emph{orange diamonds}). The bottom row presents the same data for 0 level vs 1 level. Note that much of the accuracy achieved with a very fine quadrature mesh (5 levels) can be gained by using only 1 level of refinement in the quadrature mesh. }
	\label{fig.example3_results}
\end{center}
\end{figure}

\subsection{ Propagation Examples }
\label{section.prop_examples}

In Figures \ref{fig.straight_frames}, \ref{fig.cantilever_paths}, \ref{fig.two_holes_frames}, and \ref{fig.bean_frames} we show results of using our method for simulating the propagation of cracks (for each of these examples we use Young's modulus is $10^5$ and Poisson Ratio is $.3$, and we use a fracture toughness of $1$). In each of these examples, we compute a release rate via the stress intensity factors, and propagate by a fixed increment (of $.03$) if the release rate exceeds the toughness \cite{anderson:fracture_mechanics}. In the first example, shown in Figure \ref{fig.straight_frames}, we simulate a rectangular domain that has been initialized with a straight crack. We apply symmetric displacement boundary conditions to the right and left sides of the domain, and the result is a crack that moves straight, and in the end cuts the domain into two disconnected regions. The colors of the diagrams in Figure \ref{fig.straight_frames} represent the Frobenius norm of the stress, red denotes relatively large values and blue denotes small values (we also use this color convention for the remaining figures of this section).

\begin{figure}[h]
\begin{center}
	\includegraphics[scale=.6]{figures/straight_frames}
	\caption{\captionsize Simulation of a rectangular domain with symmetric boundary displacements; from \emph{upper left}: initial configuration, 5 timesteps, 10 timesteps, 15 timesteps.}
	\label{fig.straight_frames}
\end{center}
\end{figure}

Our next propagation example involves the quasistatic propagation of a crack in a beam, as pictured in the diagram of Figure \ref{fig.cantilever_setup}. As in \cite{Belytschko99}, we use dimension of $L=11.82$ and $W=3.94$, and we varied the inital perturbation angle $\theta$, using values $1.43^{\circ}$, $2.86^{\circ}$, and $5.71^{\circ}$. The results of simulating the propagation for these three angles is presented in Figure \ref{fig.cantilever_paths}, where we have plotted the position of the crack tip at each timestep using blue triangles for $1.43$ degrees, orange squares for $2.86$, and yellow triangles for $5.71$. We use a simulation mesh resolution of 64x20, with three levels of refinement in the quadrature mesh. Our results are in good agreement with the results in \cite{Belytschko99}.

\begin{figure}[h]
\begin{center}
	\includegraphics[scale=1]{figures/cantilever_setup}
	\caption{\captionsize The setup used to show crack propagation in a beam for various values of the initial perturbation angle $\theta$.}
	\label{fig.cantilever_setup}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
	\includegraphics[scale=.6]{figures/cantilever_paths}
	\caption{\captionsize The results of cantilever beam propagation; the position of the crack tip at each timestep is plotted using blue triangles for $\theta = 1.43^{\circ}$, orange squares for $\theta = 2.86^{\circ}$, and yellow triangles for $\theta = 5.71^{\circ}$.}
	\label{fig.cantilever_paths}
\end{center}
\end{figure}

In Figure \ref{fig.two_holes_frames}, we illustrate a more complicated scenario. Our initial setup, pictured in the upper left corner of the figure, is a square (with side length of 1) that has two holes of the same radius ($r=1/64$). The simulation is initialized with two cracks, one emerging from each hole, both at $45^{\circ}$ with respect to the horizontal, so that the resulting geometry is symmetric (see the zoom-in on the holes showing the cracks, at \emph{upper right}). We subject this domain to constant traction at the right and left side of the domain. We use a simulation mesh resolution of 64x64 with two refinements for the quadrature mesh. At each step we propagate by a fixed increment of length $.03$ (where the release rate is high enough). The bottom row of the figure shows the results of the crack simulation after twenty timesteps (note that for clarity we removed the disconnected material region in between the two cracks at the final timestep).

For this example (and a later propagation example), we use the cutting algorithm to construct a mesh for the domain. The process is as follows: first, we create a triangular mesh on a square domain. Then, we describe the holes using segmented curves. These curves are provided as input to the cutting algorithm. The result is a mesh that has been cut into disconnected pieces, one piece corresponding to the interior of the domain and the rest (inside of the holes) is the exterior. We then simulate propagation on the mesh that represents the interior of the domain, by providing the crack as another segmented curve, and then using the crack to cut the domain interior. Essentially, this process treats the boundary of the domain as a ``crack'' that has fully disconnected the interior and exterior of the domain. The main benefit of this technique is that it allows the domain to have complicated boundaries, and our mesh does not have to conform to the geometry of the boundary (see Figure \ref{fig.bean_embedding} for another example). And, since the cutting algorithm can handle a crack tip inside of a triangle that has been fully cut, we can automatically handle the crack tip reaching the boundary of the domain.

\begin{figure}[h]
\begin{center}
	\includegraphics[scale=.6]{figures/two_holes_frames}
	\caption{\captionsize Cracks propagating in a domain with holes; \emph{top row}: initial configuration on \emph{left} and a zoom into the 
holes on \emph{right}; \emph{bottom row}: analagous diagrams for result after 20 timesteps.}
	\label{fig.two_holes_frames}
\end{center}
\end{figure}

In Figure \ref{fig.bean_frames} we further complicate the geometry of the domain and cracks. As in the previous example, we constructed a domain with more complicated geometry by cutting a rectangular domain ($L=2$, $W=1$, mesh resolution is 128x64 with two levels of refinement of the quadrature mesh) with the cutting algorithm. (see Figure \ref{fig.bean_embedding}). Then, we create initial cracks in the domain that have junctions, in order to illustrate the geometric flexibility of our algorithm. Note that, in this case, some of the elements will be duplicated into more than two copies, since the cracks will cut triangles near the junction into three materially distinct elements. We subject this new domain to a displacement condition at the left and right ends: we take the material in the domain which is to the left left of the line $x=-.8$ or to the right of the line $x=.8$ and apply a fixed displacement condition of $.001$; we also apply traction conditions to five other parts of the boundary (in the diagram they can be seen by the higher stresses that they produce). We then simulated the propagation of the cracks over twenty timesteps, propagating with a fixed increment length of $.03$ (where the release rate is high enough). Note that as the cracks evolve they can join with other cracks, which we accomplish by procedurally merging cracks whose paths intersect. However, the crack tips cannot branch (creating new junctions) with the propagation criterion that we use for these examples (see Section \ref{sec:chap1.propagation}).

\begin{figure}[h]
\begin{center}
	\includegraphics[scale=.8]{figures/bean_embedding}
	\caption{\captionsize  An illustration of using the cutting algorithm to mesh our domain. A square containing the domain is triangulated (shown \textit{at left}), and the cutting algorithm is run with the boundary of the domain as input. This results in two disconnected meshes, one corresponds to the interior of the domain (shown \textit{at right}) and the other is the exterior. }
	\label{fig.bean_embedding}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
	\includegraphics[scale=.6]{figures/bean_frames}
	\caption{\captionsize Simulation with complex geometry; from \emph{upper left}: initial configuration, 5 timesteps, 15 timesteps, 25 timesteps.}
	\label{fig.bean_frames}
\end{center}
\end{figure}



\section{CONCLUDING REMARKS}
\label{section.concluding_remarks}

We presented an XFEM-based method for the simulation of crack propagation. This method uses virtual nodes generated by the cutting algorithm of Sifakis, et.al., \cite{Sifakis07} to create the extra degrees of freedom that allow the crack to open, in a way that is general and flexible. Our technique gives accurate stress intensity factors, which we use to propagate the crack. Our discretization and simulation approach can accomodate complex crack and domain geometry. We illustrated the accuracy of our method by comparison with  results from the literature, and showed the geometric flexibity with propagation examples in complicated domains.

\begin{center}
ACKNOWLEDGEMENTS
\end{center}
This work was partially supported by UC Lab Fees Research Grant 09-LR-04-116741-BERA, Office of Naval Research grants N00014-03-1-0071 and N00014-10-1-0730, and National Science Foundation grants DMS-0914813 and CCF-0830554. CR was partially supported by the National Science Foundation under grant No. DMS-0714945. 

\end{comment}
