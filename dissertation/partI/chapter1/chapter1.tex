%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% partI/chapter1/chapter1.tex
%
% Copyright 2012, Jeffrey Hellrung.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Crack Propagation in Two Dimensions} \label{chap:partI.crackpropagation}

\section{Background and Existing Methods}

\footnote{The content of this chapter is a version of \cite{Richardson11} with moderate revisions.}
Since our discretization is essentially an \emph{eXtended Finite Element Method} (XFEM), we summarize the main idea and historical background of the XFEM; see \cite{Belytschko09}, \cite{Karihaloo03}, and \cite{Abdelaziz08} for more complete surveys. The idea is to enrich the usual finite element spaces with additional degrees of freedom, which incorporate the near-tip asymptotic solutions and allow the displacements to be discontinuous across the crack surface. The application of XFEM to cracks began with Belytschko and Black \cite{Belytschko99}, where they applied the partition of unity methods (see, e.g.,\cite{Melenk96}) to the problem of using finite elements with discontinuous basis functions. In \cite{Moes99} Moes et al. used XFEM to create a technique for simulating crack propagation in two dimensions without remeshing the domain. Sukumar et al. \cite{Sukumar00} began the extension to three dimensions. They used the two dimensional enrichment functions for planar cracks, and then further extended in \cite{Areias05}.

Since its introduction, XFEM enrichment has been employed in a variety of settings to model fracture. Moes and Belytschko \cite{Moes02b} modelled cohesive fracture using special enrichments, and this was extended in \cite{Zi.Goangseup03} and continues to be developed (see, e.g., \cite{Mariani03, Borst04, Asferg07}). Work in other settings includes fracture with elastodynamics \cite{Belytschko04} and crack propagation in composite materials \cite{Huynh09}. The XFEM has been combined naturally with the level set methods of Osher and Sethian \cite{Osher88, Osher04} to track the moving discontinuity sets (for cracks see, e.g., \cite{Belytschko01, Moes02a, Gravouil02, Duflot07, Prabel07}; and for holes and inclusions see \cite{Sukumar01}); Sukumar et al. \cite{Sukumar08} coupled the XFEM with fast marching methods. Bordas et al. \cite{Bordas07} studied error estimates, and various techniques have increased the rate of convergence, such as cut off functions and geometric enrichment \cite{Chahine06, Chahine08, Shen09}. However, the XFEM approach still carries a couple technical challenges: assembling the stiffness matrix requires integration of singular or discontinuous functions and implementing enrichment requires resolving material connectivity (often using a level set representation).

Quadrature for integration of the gradients of the XFEM basis functions is an active area of research because of the singularities and discontinuities present. As noted in \cite{Daux00}, the use of Gaussian quadrature or Monte Carlo integration is unstable: since the crack geometry within a given triangle is unknown a priori, quadrature points could be very close to singularities in the integrand. One approach to the problem (see, e.g., \cite{Stazi03}) is to perform a Delaunay triangulation on the cut triangle that respects the crack geometry and then use Gaussian quadrature on each of the resulting triangles. This triangulation does not produce additional degrees of freedom; it is only used for integration of the basis functions. Other methods, e.g., \cite{Bechet05, Laborde05}, map the near-tip enrichment functions to domains amenable to Gaussian quadrature, but also require meshing of the tip triangle. Another approach is to use higher order Gaussian quadrature \cite{Strouboulis00}. In \cite{Ventura09}, Ventura et al. transformed the area integral required for assembly of the stiffness matrix into a more stable line integral. Park et al. \cite{Park09} also used a mapping technique to remove the singularity for tetrahedral elements (in three dimensions), while Areias and Belytschko \cite{Areias05} used a smoothing technique. For integrating the Heaviside functions, Ventura \cite{Ventura06} used a map to equivalent polynomials which were integrated using standard quadrature techniques; Holdych et al. \cite{Holdych08} used a similar technique where they introduced a dependence of the Gaussian quadrature weights on the position of the quadrature point within the triangle. Benvenuti et al. \cite{Benvenuti08} regularized the Heaviside function for integration with Gauss quadrature and proved that the solutions converge as the regularization parameter goes to zero. Mousavi and Sukumar \cite{Mousavi10} used a quadrature rule that avoids Delaunay triangulation and does not require splitting cut elements for Heaviside enrichment. 

We introduce a simple method of integration (see \S\ref{sec:chap1.integration}) that combines naturally with the mesh cutting algorithm (see \S\ref{sec:chap1.cutting}). Our scheme involves creating a finer mesh for integration purposes only. This is similar to the approach of Ji et al. \cite{Ji.H02} and Dolbow \cite{Dolbow99}; however, we resolve the crack surface inside the quadrature elements and use an approximation of the nonlinear basis functions for the purposes of quadrature. Mousavi et al. \cite{Mousavi11} also use modified enrichment functions; however, they compute new enrichment functions by solving a partial differential equation, whereas we simply project the usual enrichment functions onto a simpler finite element space. Also in \cite{Mousavi11}, the authors solve for and integrate their enrichment functions on a mesh that is refined near the tip; since we also use such a mesh, it may be possible to incorporate their idea of computing the enrichment functions into our approach.

In order to allow cracks to open, XFEM needs to generate additional degrees of freedom, generally referred to as \emph{enrichment}. In a region that has been unambiguously separated into two pieces (i.e., away from the crack tip), the enrichment is provided by a Heaviside function, defined to be $+1$ on one side of the crack surface and $-1$ on the other side. This is easy in the case of a single straight crack but more challenging as the crack geometry becomes complicated. Daux et al. \cite{Daux00} handle the case of branched cracks by using separate enrichments for each crack, and then use another enrichment function to represent the junction itself. They then generalize this technique to cracks that have multiple branches; however, their method requires that the cracks have been hierarchically decomposed into a main crack and its branched components, and it still involves solving the problem of material connectivity. Budyn et al. \cite{Budyn04} and Zi et al. \cite{Zi.G04} extend \cite{Daux00} to incorporate multiple cracks and to address the issue of intersecting cracks. Song and Belytschko \cite{Song09a} introduced the cracking node method, which is based on XFEM and is designed to more easily handle complicated crack geometries.

The use of phantom, ghost, or virtual nodes (e.g., \cite{Molino05}) to incorporate discontinuities has become increasingly popular. The methods of Hansbo and Hansbo \cite{Hansbo04}, Song et al. \cite{Song06}, and Duan et al. \cite{Duan09} (which are equivalent; see \cite{Areias06}) use a notion of ghost or phantom degrees of freedom to handle displacement discontinuities. Song and Belytschko also use a phantom node method in \cite{Song09b}, where they additionally use the product of multiple Heaviside functions to handle branched cracks. Dolbow and Harari \cite{Dolbow09} use phantom nodes in the context of embedded interface problems. We likewise use virtual nodes by leveraging the mesh cutting algorithm in \cite{Sifakis07}, making it possible to handle complex crack geometry (such as branching) systematically. Also, our method can create different finite element spaces than the methods presented in \cite{Hansbo04} or \cite{Song06} (see \S\ref{sec:chap1.integration}).

We present a method for simulating quasistatic crack propagation in $2$ dimensions which combines the XFEM with a simple integration procedure and a the geometrically flexible mesh cutting algorithm described in \cite{Sifakis07}. To summarize, our approach

\begin{itemize}
\item is based on virtual nodes created by the mesh cutting algorithm that incorporates material connectivity,
\item can handle complicated crack patterns (including multiple tips in the same element, branching, and tips within fully cut elements),
\item can handle geometrically complex domains,
\item does not require remeshing of the domain (which is entirely in the spirit of XFEM),
\item employs a quadrature rule that again utilizes the mesh cutting algorithm, and whose degree of complexity is independent of the crack geometry.
\end{itemize}

\setlength{\figurewidth}{0.79\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/crack2}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/crack1}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/stress}
\caption{An example with a complex branching crack. (top) A crack surface cutting the simulation mesh; (center) the crack surface cutting the embedded quadrature mesh; (bottom) the computed stress field with uniform traction applied to the left and right edges.}
\label{fig:chap1.introexample}
\end{figure}

\section{Governing Equations}

We assume quasistatic evolution, such that at each fixed point in time the material is in elastic equalibrium. Denoting the rest configuration by $\Omega \subset \bbR^2$ open and bounded, we thus consider the equations of elastic equilibrium given by
\begin{align*}
\nabla \cdot \bssigma + \bfb & = \bfzero \quad \in \Omega \setminus \Gamma; \\
\bfu & = \bfu_0 \quad \in \dOmega_d; \\
\bssigma \cdot \hatn & = \bfg \quad \in \dOmega_n; \\
\bssigma \cdot \hatn & = \bfzero \quad \in \Gamma^+; \\
\bssigma \cdot \hatn & = \bfzero \quad \in \Gamma^-;
\end{align*}
where $\bssigma$ is the Cauchy stress tensor; $\bfb$ is the body force per unit volume; $\bfu$ is the (unknown) displacement; $\bfu_0$ is the Dirichlet boundary condition (applied to a subset of the boundary $\dOmega_d$); $\bfg$ is the traction (Neumann) boundary condition (applied to $\dOmega_n$); $\hatn$ denotes the unit outward-pointing normal; $\Gamma$ is the crack surface; and $\Gamma^+, \Gamma^-$ represent the two opposite orientations of the crack surface. In the present exposition, we consider the case of small strains and displacements, where linear elasticity is an accurate model of material behavior. Hence we use the Cauchy strain
\begin{equation*}
\bsepsilon(\bfu) := \nabla_S \bfu := \frac{1}{2} \lrp{\nabla \bfu + (\nabla \bfu)^t}
\end{equation*}
and stress
\begin{equation*}
\bssigma := \bfC : \bsepsilon
\end{equation*}
where $\bfC$ is the Hooke tensor. Equivalently, one may consider minimizing over $\bfu$ the potential energy
\begin{equation} \label{eq:chap1.energy}
\Psi[\bfu] := \frac{1}{2} \int_{\Omega} \bsepsilon(\bfu) : \bfC : \bsepsilon(\bfu) d\bfx - \int_{\Omega} \bfb \cdot \bfu d\bfx - \int_{\dOmega_n} \bfg \cdot \bfu d\bfS(\bfx)
\end{equation}
subject to $\bfu = \bfu_0$ on $\dOmega_d$.

\section{Extended Finite Elements} \label{sec:chap1.xfem}

Conceptually, the starting point of our work is the eXtended Finite Element Method \linebreak[4] (XFEM), which was originally motivated and studied in the context of fracture by Belytschko et al.; see, e.g., \cite{Moes99}. In the original XFEM, a simulation with quasistatics evolution requires one to solve a discrete approximation to the equations of elastic equilibrium at each time step. The approximation subspace is formed by taking the usual $C_0$ conforming finite element space (in our case, on triangles) and \emph{enriching} with additional degrees of freedom that allow cracks to open and increase the accuracy of the approximation near the crack tip. Thus, functions in an XFEM space $\calU^h$  have the form
\begin{equation} \label{eq:chap1.xfem}
\bfu^h(\bfx) = \sum_i \bfu_i \phi_i(\bfx) + \sum_j \bfb_j \phi_j(\bfx) H(\bfx) + \sum_k \phi_k(\bfx) \sum_{\ell = 1}^4 \bfc_k^{\ell} F_{\ell} \lrp{r(\bfx), \theta(\bfx)},
\end{equation}
where $\{\phi_i\}$ are the usual nodal basis functions; $H(\bfx)$ is the Heaviside function associated to the current crack geometry; $\{\bfb_j\}$ are enrichment degrees of freedom associated with crack separation away from the crack tip; $ \{\bfc_k^\ell\}$ are enrichment degrees of freedom associated with near-tip displacement; and
\begin{equation*}
\set{F_{\ell}(r,\theta)} := \set{ \sqrt{r} \sin \frac{\theta}{2}, \sqrt{r} \cos \frac{\theta}{2}, \sqrt{r} \sin \frac{\theta}{2} \sin \theta, \sqrt{4} \cos \frac{\theta}{2} \sin \theta }
\end{equation*}
are the asymptotic near-tip enrichment functions ($r$ and $\theta$ are the polar coordinates with respect to the crack tip). Notice that \eqref{eq:chap1.xfem} expresses $\bfu^h$ as a linear combination of three types of basis functions: the usual nodal basis functions (which have support local to mesh vertices), Heaviside enrichment functions, and near-tip enrichment functions (which have support local to the crack tip). The sum over $i$ in \eqref{eq:chap1.xfem} is over all mesh vertices, while the sums over $j$ and $k$ are over those vertices whose corresponding conforming basis functions have support that intersects the crack surface (see \cite{Moes99}). We use the term \emph{one-ring} of a vertex to refer to the set of elements composing the support of the corresponding nodal basis function. Strictly speaking, \eqref{eq:chap1.xfem} only accounts for a single crack tip, but it may be generalized to accomodate crack geometries with multiple tips.

\section{Cutting of Cracked Domains} \label{sec:chap1.cutting}

To simplify the exposition, we first focus on the discretization away from any crack tips (thus ignoring tip enrichment) where \eqref{eq:chap1.xfem} takes the simpler form
\begin{equation*}
\bfu^h(\bfx) = \sum_i \bfu_i \phi_i(\bfx) + \sum_{j \in J} \bfb_j \phi_j(\bfx) H(\bfx),
\end{equation*}
where $J$ is the set of vertices whose one-ring intersects the crack surface. We begin by replacing these more traditional Heaviside-enriched degrees of freedom with more geometrically intuitive virtual nodes (see \cite{Molino05}), also known as ghost or phantom nodes (see, e.g., \cite{Song06}, \cite{Hansbo04}, \cite{Dolbow09}). As discussed in the prelude to Part I, these virtual nodes are automatically created by the mesh cutting algorithm of Sifakis et al. \cite{Sifakis07}. Figures~\ref{fig:chap1.cutting.unrefined} and \ref{fig:chap1.cutting.refined} illustrate an example of the mesh cutting algorithm more closely related to our present application. In Figure~\ref{fig:chap1.cutting.unrefined}, we introduce a crack which completely cuts one triangle and only partially cuts another. In Figure~\ref{fig:chap1.cutting.refined}, we introduce the same crack into a locally refined mesh. In the present context, the unrefined mesh corresponds to the simulation mesh, while the refined mesh -- after being cut as in the example -- corresponds to the quadrature mesh (see \S\ref{sec:chap1.integration}).

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/cutting2}
\caption{A crack is introduced into the mesh on the left, yielding the enriched mesh on the right, with duplicated triangles and virtual nodes, which we use as our simulation mesh.}
\label{fig:chap1.cutting.unrefined}
\end{figure}

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/cutting3}
\caption{For quadrature purposes, we refine the uncut mesh in Figure~\ref{fig:chap1.cutting.unrefined}(left) around the cut (upper left), then cut this refined mesh (bottom). A blow up of the region near the crack (upper right) shows the virtual nodes relative to the crack surface.}
\label{fig:chap1.cutting.refined}
\end{figure}

Now, consider a mesh that has been cut, with the associated duplication of elements and introduction of virtual nodes. Corresponding to each virtual node, we create a nodal basis function that respects the crack geometry, i.e., we take into account that vertices and triangles may have been duplicated (see Figure~\ref{fig:chap1.truncatedbasis} for a one-dimensional illustration). Let $\{\tilde{\phi}_i\}$ be the usual piecewise affine nodal basis ``hat'' functions on the simulation mesh, and let $\bfx_i$ be the vertex (which may be a virtual node) corresponding to a given $\tilde{\phi}_i$. Denote by $\Omega_i$ the collection of triangles in the one-ring of vertex $\bfx_i$. Given the preceding notation, we define a new \emph{truncated} hat function $\phi_i$ via
\begin{equation} \label{eq:chap1.truncatedbasis}
\phi_i(\bfx) := \tilde{\phi}_i(\bfx) \sum_{T \in \omega_i} \chi_T^M(\bfx),
\end{equation}
where $\chi_T^M$ is the characteristic function of the material region of triangle $T$.

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/truncated_basis}
\caption{A truncated basis function in dimension $1$. At left, a mesh element with vertices $1$ and $2$ is cut by the red dot, resulting in the two duplicate elements on the right. The original nodal basis ``hat'' function $\tilde{\phi}_2$ corresponding to vertex $2$ (green) gets truncated into derived basis functions $\phi_2$ and $\phi_4$ according the material region within each duplicate element.}
\label{fig:chap1.truncatedbasis}
\end{figure}

In many cases, this virtual node approach is equivalent to the more traditional use of Heaviside enrichment as well as the methods of Song et al. \cite{Song06} and Hansbo and Hansbo \cite{Hansbo04}, i.e., they give equivalent finite element spaces. However, certain crack geometries do, in fact, yield different spaces. As an example, the configuration in Figure~\ref{fig:chap1.triplecut}(left) is cut by a crack given by the red line. The resulting finite element spaces differ between the two methods. Heaviside enrichment and the methods of Song et al. \cite{Song06} and Hansbo and Hansbo \cite{Hansbo04} yield the degrees of freedom depicted in Figure~\ref{fig:chap1.triplecut}(center), while the mesh cutting algorithm from \cite{Sifakis07} yields the degrees of freedom depicted in Figure~\ref{fig:chap1.triplecut}. Since the material region of the top triangle to the right of the crack surface is not materially connected to the bottom triangle, the bottom left virtual nodes are allowed to separate (see top-right of Figure~\ref{fig:chap1.triplecut}). Generally speaking, the finite element spaces resulting from the mesh cutting algorithm are at least as rich as the spaces resulting from Heaviside enrichment, and in some situations it may in fact be strictly richer (i.e., have strictly larger dimension).

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/triple_cut}
\caption{Given the uncut mesh and crack at left, XFEM using traditional Heaviside enrichment yields $8 \times 2$ degrees of freedom (center), while using virtual nodes as described in \S\ref{sec:chap1.cutting} yields $9 \times 2$ degrees of freedom (right).}
\label{fig:chap1.triplecut}
\end{figure}

Finally, we note that Sifakis et al. \cite{Sifakis07}, in their presentation of the mesh cutting algorithm, make the simplifying assumption that the cutting surface never coincides with a mesh vertex or aligns with an element face. Nevertheless, the virtual node algorithm is perfectly compatible with such degenerate cases, and this simplifying hypothesis is made only to ease certain implementation challenges related to the representation of the crack surface as an explicit simplex mesh. In fact, the mesh cutting algorithm can accommodate any cut configuration, including these degenerate cases, as long as the following two queries can be algorithmically determined: (a) the number of disjoints fragments a given element is divided into; and (b) material connectivity of element fragments originating from face-adjacent elements.

For example, if the crack surface is instead represented implicitly as the zero isocontour of a level set function sampled at the vertices of the simulation mesh (or a refinement thereof), both of the above queries admit a straightforward algorithm determination, and hence the element duplication and joining algorithm described in \cite{Sifakis07} may be applied, even when the zero isocontour coincides with a mesh vertex. In the present case, with the crack surface represented explicitly as a simplex mesh (segmented curve in $2$ dimensions or triangulated surface in $3$ dimensions), the robust determination of (a) and (b) is challenging given the limited precision of typical floating point arithmetic. Rather than complicate the implementation to address degenerate or near-degenerate scenarios, we found it preferable and practical to avoid these scenarios entirely by simply perturbing the crack surface negligibly. Naturally, if we use a level set representation, no such perturbation is necessary.

\section{Integration} \label{sec:chap1.integration}

Our integration scheme utilizes a subordinate quadrature mesh in addition to the primary simulation mesh, the details of which we describe here. For simplicity, we assume a domain-conforming triangulation, creating a mesh corresponding to Figure~\ref{fig:chap1.cutting.unrefined}(left). We then construct a pair of derived meshes:
\begin{itemize}
\item We apply the mesh cutting algorithm to resolve the crack surface against the original mesh, yielding the \emph{simulation mesh}, corresponding to Figure~\ref{fig:chap1.cutting.unrefined}(right). The simulation mesh contains the actual simulation degrees of freedom, include both virtual and crack tip enrichment degrees of freedom.
\item We also locally refine the original mesh around the crack and resolve the crack against this refined mesh, yielding the \emph{quadrature mesh}, corresponding to Figure~\ref{fig:chap1.cutting.refined}(right). The quadrature mesh only possesses nodal degrees of freedom (i.e., no crack tip enrichment degrees of freedom), and these degrees of freedom are subordinate to the interpolated values from the simulation mesh. We only use the quadrature mesh to aid in the integrations involving the enrichment functions on the simulation mesh, and it does not add additional degrees of freedom to the system.
\end{itemize}
We solve the equilibrium equations of linear elasticity on the relatively coarse simulation mesh (with fewer degrees of freedom), but perform the requisite integrations on the relatively fine quadrature mesh by approximating the (generally nonlinear) basis functions over the simulation mesh with piecewise affine projections over the quadrature mesh. We then use a composite one-point quadrature rule over the quadrature mesh.

Our integration scheme is similar to another scheme presented in the XFEM literature (e.g., \cite{Stazi03}). The main idea is to compute a Delaunay triangulation respecting the crack geometry within each simulation triangle and assembling the stiffness matrix by applying Gaussian quadrature over each Delaunay triangle. Hence, like our scheme, this employs a finer triangulation of the original mesh solely for integration purposes and does not add degrees of freedom to the simulation. However, our integration scheme uses the mesh cutting algorithm \cite{Sifakis07} to resolve the crack geometry within the quadrature mesh (see, e.g., Figure~\ref{fig:chap1.introexample}(center)), and so, in contrast to Delaunay triangulation, the quadrature mesh will only approximately conform to the crack geometry. This has the advantage of decoupling the resolution of the quadrature mesh from the resolution of the crack surface. Further, this use of the mesh cutting algorithm naturally extends to higher dimensions, where Delaunay tessellations become significantly more challenging.

\subsection{Construction of the Simulation Mesh and Quadrature Mesh}

We now describe the construction of our key meshes in more detail, and we will use notation consistent with \cite{Braess07}. We construct the simulation mesh as described in \S\ref{sec:chap1.cutting}. Using the modified hat functions from \eqref{eq:chap1.truncatedbasis}, we define our (simulation) finite element space $\bfV^h$ as those vector-valued functions $\bfu^h$ of the form
\begin{equation} \label{eq:chap1.xfem2}
\bfu^h(\bfx) = \sum_i \bfu_i \phi_i(\bfx) + \sum_k \phi_k(\bfx) \sum_{\ell = 1}^4 \bfc_k^{\ell} F_{\ell} \lrp{r(\bfx), \theta(\bfx)}
\end{equation}
where $\{F_{\ell}\}$ are the asymptotic near-tip enrichment functions given in \S\ref{sec:chap1.xfem}. The difference between \eqref{eq:chap1.xfem2} and \eqref{eq:chap1.xfem} is that \eqref{eq:chap1.xfem2} already incorporates the Heaviside enrichment (the sum over $j$ in \eqref{eq:chap1.xfem}) via the introduction of virtual nodes and the truncated basis functions. We let $F^h := \{\bfu_i, \bfc_k^{\ell}\}$ denote the degrees of freedom of $\bfV^h$ and identify $F^h$ with $\bbR^N$, where $N$ is the number of degrees of freedom in the simulation.

We now discuss the construction of the quadrature mesh. We begin by regularly refining triangles in the original mesh that intersect the crack surface. This refinement is progressively graded as the distance from the crack increases via red-green refinement \cite{Molino03}. We resolve the crack surface against this refined mesh via the mesh cutting algorithm to yield the quadrature mesh; this ensures the quadrature mesh will respect the crack topology (see Figure~\ref{fig:chap1.cutting.refined}). We then define a quadrature finite element space $\bfV_q^h$ to be the piecewise affine finite element space over this quadrature mesh, i.e., $\bfu_q^h \in \bfV_q^h$ takes the form
\begin{equation} \label{eq:chap1.xfem.refined}
\bfu_q^h(\bfx) = \sum_i \bfu^q_i \phi^q_i(\bfx)
\end{equation}
where $\{\phi^q_i\}$ are the associated truncated nodal basis functions (as in \eqref{eq:chap1.truncatedbasis}). We let $F_q^h := \{\bfu^q_i\}$ denote the degrees of freedom of $\bfV_q^h$ and identify $F_q^h$ with $\bbR^M$, where $M$ is twice the number of vertices in the quadrature mesh. Since we do not employ the asymptotic near-tip enrichment functions in the quadrature finite element space (as we do for the simulation finite element space), all the degrees of freedom $F_q^h$ can be identified with a vertex in the quadrature mesh and a coordinate direction.

We use the quadrature mesh and associated finite element space to approximate the integrals of the gradients of the $\bfV^h$-basis functions. To this end, we subordinate the quadrature mesh to the simulation mesh via a fixed linear relationship between $F_q^h$ and $F^h$ (see \cite{Sifakis07b}). Consider $\bfu^q_i \in F_q^h$ and the position of its corresponding mesh node $\bfx^q_i$. We express $\bfu^q_i$ in terms of the simulation degrees of freedom $F^h$ using \eqref{eq:chap1.xfem2}:
\begin{equation} \label{eq:chap1.binding}
\bfu^q_i = \sum_j \bfu_j \phi_j(\bfx^q_i) + \sum_k \phi_k(\bfx^q_i) \sum_{\ell = 1}^4 \bfc_k^{\ell} F_{\ell} \lrp{r(\bfx^q_i), \theta(\bfx^q_i)}.
\end{equation}
Note that the sume over $j$ involves at most $3$ nonzero terms as $\bfx^q_i$ can be in the support of at most three of the $\phi_j$'s. According to \eqref{eq:chap1.binding}, the quadrature degrees of freedom $\bfu^q_i$ are functionally constrained to the simulation degrees of freedom $\{\bfu_i, \bfc_k^{\ell}\}$ and hence do not introduce any new degrees of freedom. This effectively defines a linear relationship between the quadrature and simulation degrees of freedom which we denote by the matrix $W$ (see below). Binding the quadrature mesh to the simulation mesh in this fashion allows us to project the basis functions of $\bfV^h$ onto $\bfV_q^h$ and operate on these projections in the piecewise affine quadrature finite element space, where the integration is simpler.

Special care must be taken when computing the polar coordinates $(r(\bfx^q_i), \theta(\bfx^q_i))$ of $\bfx^q_i$ when it corresponds to a virtual node. As illustrated in Figure~\ref{fig:chap1.binding.virtual}, for virtual nodes, we must reverse the orientation of the angle $\theta$ with respect to the crack, allowing it to take values outside the typical $[-\pi,+\pi]$ bounds. We effectively associate a virtual node with the opposite side of the crack surface, where the material region associate with the virtual node resides. This ensures that $\theta(\bfx)$ is continuous throughout the triangle.

\setlength{\figurewidth}{0.50\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/bind_virtual}
\caption{The polar angle of a virtual node in the quadrature mesh is measured across the crack surface to ensure continuity of $\theta$ throughout a quadrature triangle.}
\label{fig:chap1.binding.virtual}
\end{figure}

\subsection{Integration Scheme}

The relation \eqref{eq:chap1.binding} binds the quadrature degrees of freedom $F_q^h$ to the simulation degrees of freedom $F^h$. Letting $\vec{u} \in F^h$ and $\vec{u}^q \in F_q^h$, we can encode the coefficients of \eqref{eq:chap1.binding} in a matrix $W$, such that $\vec{u}^q = W \vec{u}$. Let $A$ and $A^q$ denote the stiffness matrices associated with the energy \eqref{eq:chap1.energy} discretized over the finite element spaces $\bfV^h$ and $\bfV_q^h$, respectively; and let $\alpha$ denote the bilinear form associated with \eqref{eq:chap1.energy}. Since $\bfV_q^h$ is a piecewise affine finite element space, there is a natural and standard procedure to assemble its stiffness matrix $A^q$. Our integration scheme then approximates the true stiffness matrix $A$ via
\begin{equation} \label{eq:chap1.Atransform}
\vec{u}^t A \vec{u} = \alpha(\bfu^h, \bfu^h) \approx \alpha(\bfu_q^h, \bfu_q^h) = (\vec{u}^q)^t A^q \vec{u}^q = \vec{u}^t W^t A^q W \vec{u},
\end{equation}
where $\bfu^h$ ($\bfu_q^h$) is the function in $\bfV^h$ ($\bfV_q^h$) corresponding to the vector $\vec{u} \in F^h$ ($\vec{u}^q \in F_q^h$). It follows that $A \approx W^t A^q W$.

Ultimately, our integration scheme utilizes an approximation (indeed, a projection) of the non-smooth basis functions (see Figure~\ref{fig:chap1.sampling}), with this approximation improving as one further refines the quadrature mesh. Note that we may end up sampling a singular basis function near the singularity. However, unlike integration schemes based on Gaussian quadrature or Monte Carlo methods, any function evaluations at these sampling points will be weighted by the area of the smaller quadrature triangle. Thus, no single sample, possibly located near the tip singularity, contributes disproportionally. Finally, we note that for simplicity and improved stability, we can further approximate the integrations implicit in \eqref{eq:chap1.Atransform} by treating cut quadrature triangles as if they were full of material, i.e., removing the characteristic function multiplications in \eqref{eq:chap1.truncatedbasis} and assembling $A^q$ over the usual nodal basis ``hat'' functions. This optional modification vanishes under refinement of the quadrature mesh, as the error caused by the additional basis function support goes to zero. In \S\ref{sec:chap1.examples}, our examples account for the material region in cut quadrature triangles. We additionally present some comparisons between treating quadrature triangles as completely full and respecting the actual material regions.

\setlength{\figurewidth}{0.50\textwidth}
\begin{figure}[htbp]
\centering
\subfloat[]
{\includegraphics[width=\figurewidth]{partI/chapter1/figures/lowres}}
\subfloat[]
{\includegraphics[width=\figurewidth]{partI/chapter1/figures/highres}}
\caption{Two samplings of the asymptotic near-tip enrichment function $F_1 = \sqrt{r} \sin \frac{\theta}{2}$. (a) shows a sampling at a low resolution, while (b) shows a sampling at a high resolution.}
\label{fig:chap1.sampling}
\end{figure}

\section{Crack Propagation} \label{sec:chap1.propagation}

For a fixed state of the system (a given crack and boundary conditions and associated equilibrium displacement), engineers use several different criteria to determine the angle at which the crack should propagate. We follow Mo\"{e}s et al. \cite{Moes99} in using the maximum circumferential stress criterion to compute the propagation direction and then move the crack by a small fixed increment. We choose this approach so that the results of using our integration technique can be compared against the test cases in \cite{Moes99}. This method is fairly standard and the details are found in the references, so we only sketch it here.

The criterion involves computing the stress intensity factors at the crack tip, and then calculating the angle of maximal stress via
\begin{equation*}
\theta_c := 2 \arctan \lrp{\frac{1}{4} \lrp{\frac{K_{\text{I}}}{K_{\text{II}}} \pm \sqrt{\lrp{\frac{K_{\text{I}}}{K_{\text{II}}}}^2 + 8}}}.
\end{equation*}
We compute the stress intensity factors using the so-called interaction J-integral, which is defined for two possible states of the system, which we denote using superscripts $1$ and $2$:
\begin{equation} \label{eq:chap1.Jintegral}
I^{(1,2)} := \int_{\Gamma} \lrp{W^{(1,2)} \delta_{1j} - \lrp{\sigma_{ij}^{(1)} u_{i,1}^{(2)} + \sigma_{ij}^{(2)} u_{i,1}^{(1)}}} n_j d\bfS
\end{equation}
where
\begin{equation*}
W^{(1,2)} := \sigma_{ij}^{(1)} \epsilon_{ij}^{(2)}.
\end{equation*}
Choosing the two states to be the current state and a pure Mode I state in the above gives $K_{\text{I}}$:
\begin{equation*}
K_{\text{I}} := \frac{1}{2} E^* I^{(\text{current}, \text{Mode I})},
\end{equation*}
where
\begin{equation*}
E^* = \begin{cases} {\displaystyle \frac{E}{1 - \nu^2}}, & \text{plane strain} \\ E, & \text{plane stress} \end{cases},
\end{equation*}
and $E$ is Young's modulus and $\nu$ is Poisson's ratio. $K_{\text{II}}$ is found using a similar relation but with a pure Mode II state. As in \cite{Moes99}, we compute these interaction integrals by converting them into area intregrals via multiplication by a suitably smooth test function and applying integration by parts. We then compute the resulting area integral on the quadrature mesh described in \S\ref{sec:chap1.integration}. Having used finite elements to compute the displacement, the stresses and strains for the current state of the system are piecewise affine on the quadrature mesh. We then interpolate the displacements, strains, and stresses for the pure Mode I and pure Mode II solutions used to compute \eqref{eq:chap1.Jintegral} using functions in the space $\bfV_q^h$. The required integrations are then simple to compute, since all the quantities in \eqref{eq:chap1.Jintegral} are piecewise affine. 

\section{Numerical Examples and Experiments} \label{sec:chap1.examples}

We tested our approach with some examples from the literature 
(\cite{Belytschko99} and \cite{Moes99}). We chose these examples because the exact stress intensity factors (or good approximations) can be calculated analytically for comparision; we also compare our results to the literature.

As discussed in Section \ref{sec:chap1.integration}, we computed our approximate solutions by integrating over just the material regions of cut quadrature triangles. For Example 1 below, we also compare this with integrating over the entire area of cut quadrature triangles.

As in \cite{Moes99}, all of our examples use a Young's modulus of $E := 10^5$ and Poisson's ratio of $\nu := 0.3$. For our propagation examples, we chose a fracture toughness of $1$.

\subsection{Example 1: Straight Crack with Pure Mode I Displacement}

Example 1 involves a straight center crack in a rectangular body with a constant traction applied to part of the boundary of the body; see Figure~\ref{fig:chap1.example1.setup} (as in \cite{Moes99}, we use $L := 16$, $W: = 7$, $a := 3.5$, $\epsilon := 100 [\text{kpsi}]$ and $\nu := 0.3$).

\setlength{\figurewidth}{0.20\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example1_setup}
\caption{The setup for Example 1.}
\label{fig:chap1.example1.setup}
\end{figure}

In this case, the exact Mode I stress intensity factor is given by
\begin{equation*}
K_{\text{I}} = C \sigma \sqrt{a \pi},
\end{equation*}
where $C$ is a finite geometry correction factor:
\begin{equation*}
C := 1.12 - 0.231 \lrp{\frac{a}{W}} + 10.55 \lrp{\frac{a}{W}}^2 - 21.72 \lrp{\frac{a}{W}}^3 + 30.39 \lrp{\frac{a}{W}}^4.
\end{equation*}
We normalize $K_{\text{I}}$ through an appropriate choice of $\sigma$ and compare our results over various combinations of granularity of the simulation mesh and refinement level of the quadrature mesh. Table~\ref{tab:chap1.example1.results} contains the results of this study. The resolution of the simulation mesh varies over the columns while the refinement level of the quadrature mesh varies over the rows. Note that the numerical stress intensity factors improve as the simulation mesh is refined, as expected, but we also get good results by pairing a coarse simulation mesh with a relatively refined quadrature mesh (of course, only up to a limit that is determined by the simulation resolution). Also, increasing the refinement level of the quadrature mesh has roughly the same effect as increasing the resolution of the simulation mesh, and that accuracy improvement is acheived at a lower computational cost since refining the quadrature mesh does not add new degrees of freedom to the system. Figure~\ref{fig:chap1.example1.convergence} illustrates the results of three convergence tests for this example (using $1$, $3$, and $5$ levels of quadrature mesh refinement). These plots clearly show first order convergence respect to the simulation mesh resolution. Finally, Figures~\ref{fig:chap1.cut_nocut.convergence} and \ref{fig:chap1.cut_nocut.diff} compare the use of respecting the actual material regions in the quadrature against treating the quadrature triangles as completely full. Both of these approaches give linear convergence, with slightly different constants. Further, the difference between those two methods goes to zero under refinement of the quadrature mesh (keeping the resolution of the simulation mesh fixed).

\begin{table}[htbp]
\centering
\begin{tabular}{c|c|.@{}.@{}.@{}.|}
\cline{2-6}
& Levels
& \multicolumn{1}{r}{$64\times32$}
& \multicolumn{1}{r}{$128\times64$}
& \multicolumn{1}{r}{$256\times128$}
& \multicolumn{1}{r|}{$512\times256$} \\
\cline{2-6}
\multirow{6}{*}{$K_{\text{I}}$}
& 0 & 7.25207 & 3.02688 & 1.68144 & 1.22950 \\
& 1 & 0.87748 & 0.93603 & 0.96710 & 0.98310 \\
& 2 & 0.90933 & 0.95357 & 0.97632 & 0.98783 \\
& 3 & 0.92324 & 0.96132 & 0.98039 & 0.98991 \\
& 4 & 0.93210 & 0.96621 & 0.98296 & 0.99122 \\
& 5 & 0.93858 & 0.96979 & 0.98482 & 0.99217 \\
\cline{2-6}
\multirow{6}{*}{$K_{\text{II}}$}
& 0 & 17.22220 & 5.78543  &  2.01135 &  0.70673 \\
& 1 & -0.00252 & -0.00117 & -0.00068 & -0.00037 \\
& 2 &  0.00003 &  0.000004& -0.00010 & -0.00008 \\
& 3 & -0.00210 & -0.00091 & -0.00052 & -0.00028 \\
& 4 & -0.00245 & -0.00107 & -0.00059 & -0.00031 \\
& 5 & -0.00267 & -0.00117 & -0.00063 & -0.00034 \\
\cline{2-6}
\end{tabular}
\caption{Results for Example 1. Theory gives $K_{\text{I}} = 1$, $K_{\text{II}} = 0$. ``Levels'' refers to the refinement level of the quadrature mesh.}
\label{tab:chap1.example1.results}
\end{table}

\setlength{\figurewidth}{0.49\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example1_1_i}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example1_1_ii} \\
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example1_3_i}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example1_3_ii} \\
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example1_5_i}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example1_5_ii}
\caption{Log-log convergence plots of the errors in $K_{\text{I}}$ (left) and $K_{\text{II}}$ (right) for Example 1. Each row corresponds to a fixed refinement level of the quadrature mesh: $1$ level (top), $3$ levels (center), and $5$ levels (bottom). All the linear regressions fit to the plots have slopes close to $-1$, incidating first order convergence.}
\label{fig:chap1.example1.convergence}
\end{figure}

\setlength{\figurewidth}{0.49\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example1_1_i_cutcell}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example1_1_ii_cutcell} \\
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example1_5_i_cutcell}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example1_5_ii_cutcell}
\caption{Log-log convergence plots of the errors in $K_{\text{I}}$ (left) and $K_{\text{II}}$ (right) for Example 1. Each row corresponds to a fixed refinement level of the quadrature mesh: $1$ level (top) and $5$ levels (bottom). Each plot compares respecting the material region within a cut quadrature triangle during integration against treating the quadrature triangle as completely full. The results indicate first order convergence regardless of the method.}
\label{fig:chap1.cut_nocut.convergence}
\end{figure}

\setlength{\figurewidth}{0.49\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/difference_cutcell_example1_i}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/difference_cutcell_example1_ii}
\caption{Plots illustrating the difference betwen respecting the material region within a cut quadrature triangle during integration against treating the quadrature triangle as completely full. We show the differences between $K_{\text{I}}$ (left) and $K_{\text{II}}$ (right) as we vary the quadrature mesh refinement level on a $64 \times 32$ resolution simulation mesh.}
\label{fig:chap1.cut_nocut.diff}
\end{figure}

\subsection{Example 2: Straight Crack with Constant Shear Displacement}

Example 2 uses the same geometric configuration as Example 1, but this time we apply a zero displacement Dirichlet boundary condition to one end of the domain and a constant shear (with respect to the crack frame) traction boundary condition to the other end; see Figure~\ref{fig:chap1.example2.setup}. The stress intensity factors are known (see \cite{Moes99}): $K_{\text{I}} = 34.0 \, [\text{psi}\sqrt{\text{in}}]$ and $K_{\text{II}} = 4.55 [\text{psi}\sqrt{\text{in}}]$. As for Example 1, we vary both the resolution of the simulation mesh and the refinement level of the quadrature mesh, with the results summarized in Table~\ref{tab:chap1.example2.results} and convergence plots in Figure~\ref{fig:chap1.example2.convergence}.

\setlength{\figurewidth}{0.20\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example2_setup}
\caption{The setup for Example 2.}
\label{fig:chap1.example2.setup}
\end{figure}

\begin{table}[htbp]
\centering
\begin{tabular}{c|c|.@{}.@{}.@{}.|}
\cline{2-6}
& Levels
& \multicolumn{1}{r}{$64\times32$}
& \multicolumn{1}{r}{$128\times64$}
& \multicolumn{1}{r}{$256\times128$}
& \multicolumn{1}{r|}{$512\times256$} \\
\cline{2-6}
\multirow{6}{*}{$K_{\text{I}}$}
& 0 & 27.53640 & 30.42170 & 32.13890 & 33.06540 \\
& 1 & 29.62800 & 31.79550 & 32.90860 & 33.47320 \\
& 2 & 30.72490 & 32.40350 & 33.22860 & 33.63730 \\
& 3 & 31.21530 & 32.67390 & 33.37000 & 33.70950 \\
& 4 & 31.51230 & 32.83990 & 33.45720 & 33.75420 \\
& 5 & 31.73140 & 32.96180 & 33.52120 & 33.78710 \\
\cline{2-6}
\multirow{6}{*}{$K_{\text{II}}$}
& 0 & 7.81139 & 5.55605 & 4.86779 & 4.64271 \\
& 1 & 4.36623 & 4.46139 & 4.49335 & 4.51208 \\
& 2 & 4.40807 & 4.49142 & 4.51380 & 4.52418 \\
& 3 & 4.34959 & 4.46972 & 4.50476 & 4.52010 \\
& 4 & 4.34610 & 4.46936 & 4.50504 & 4.52036 \\
& 5 & 4.34312 & 4.46894 & 4.50513 & 4.52048 \\
\cline{2-6}
\end{tabular}
\caption{Results for Example 2. Theory gives $K_{\text{I}} = 34.0$, $K_{\text{II}} = 4.55$. ``Levels'' refers to the refinement level of the quadrature mesh. Note that most of the benefits of the quadrature mesh are realized after only $2$ or $3$ levels of refinement; beyond that the approximation error from the simulation finite element space dominates the integration error from utilizing the quadrature mesh.}
\label{tab:chap1.example2.results}
\end{table}

\setlength{\figurewidth}{0.49\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example2_1_i}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example2_1_ii} \\
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example2_3_i}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example2_3_ii} \\
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example2_5_i}
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example2_5_ii}
\caption{Log-log convergence plots of the errors in $K_{\text{I}}$ (left) and $K_{\text{II}}$ (right) for Example 2. Each row corresponds to a fixed refinement level of the quadrature mesh: $1$ level (top), $3$ levels (center), and $5$ levels (bottom). All the linear regressions fit to the plots have slopes very close to $-1$, incidating first order convergence.}
\label{fig:chap1.example2.convergence}
\end{figure}

\subsection{Example 3: Angled Center Crack with Mixed Mode Displacement}

We borrow the example in Section 4.3 of \cite{Moes99} for Example 3. The domain is a square plate with an angled center crack which is subjected to a far field constant traction; see Figure~\ref{fig:chap1.example3.setup}. We use the parameters $W = 10 [\text{in}]$ and $a = 0.5 [\text{in}]$. Since the crack size is small and far removed from the plate boundaries, the stress intensity factors may be approximated as if the domain were the entire plane, giving
\begin{subequations} \label{eq:chap1.example3.K}
\begin{align}
K_{\text{I}} & = \sigma  \sqrt{\pi a} \cos^2 \beta, \\
K_{\text{II}} & = \sigma \sqrt{\pi a} \sin \beta \cos \beta.
\end{align}
\end{subequations}

\setlength{\figurewidth}{0.25\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/example3_setup}
\caption{The setup for Example 3.}
\label{fig:chap1.example3.setup}
\end{figure}

We compute the stress intensity factors as $\beta$ ranges from $0$ to $\pi/2$ in increments of $\pi/20$. Our simulation mesh has resolution $64 \times 64$ and we use a variety of refinement levels for the quadrature mesh. Figure~\ref{fig:chap1.example3.results} shows the relative error in the numerically computed stress intensity factors compared to the approximations \eqref{eq:chap1.example3.K}. Our results are comparable to \cite{Moes99}.

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/angle_64_data}
\caption{Results for Example 3. The top row compares the relative errors in $K_{\text{I}}$ (left) and $K_{\text{II}}$ (right) for $0$ levels of quadrature mesh refinement (blue squares) and $5$ levels of quadrature mesh refinement (orange diamonds). The bottom row compares $0$ levels of refinement to just $1$ level of refinement. Note that much of the accuracy improvement achieved with a very fine quadrature mesh ($5$ levels of refinement) is already present at only $1$ level of refinement of the quadrature mesh.}
\label{fig:chap1.example3.results}
\end{figure}

\subsection{Propagation Examples}

Figures~\ref{fig:chap1.examples.propagation.straight}, \ref{fig:chap1.examples.propagation.cantilever.setup}, \ref{fig:chap1.examples.propagation.two_holes}, and \ref{fig:chap1.examples.propagation.bean} show the results of applying our method to simulate the propagation of cracks (see \S\ref{sec:chap1.propagation}). Each of these examples uses a Young's modulus of $E := 10^5$, Poisson's ratio of $\nu := 0.30$, and fracture toughness of $1$. For each example, we compute a release rate via the stress intensity factors and propagate the crack by a fixed increment of $0.03$ if the release rate exceeds the toughness \cite{Anderson05}.

In Figure~\ref{fig:chap1.examples.propagation.straight}, we simulate a rectangular domain initialized with a straight crack with symmetric displacement Dirichlet boundary conditions applied to the left and right sides of the domain. The result is a crack propagating in a straight line that eventually divides the domain into disconnected halves. The colors used in Figure~\ref{fig:chap1.examples.propagation.straight} represent the Frobenius norm of the stress, with the maximum norm in red and the minimum norm in blue (we use this color convention in the remaining figures as well).

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/straight_frames}
\caption{Simulation of a rectangular domain with symmetric boundary displacements; initial configuration (upper left), at $5$ time steps (upper right), at $10$ time steps (lower left), and at $15$ time steps (lower right).}
\label{fig:chap1.examples.propagation.straight}
\end{figure}

Figure~\ref{fig:chap1.examples.propagation.cantilever.setup} shows the initial setup for the quasistatic propagation of a crack in a beam. As in \cite{Belytschko99}, we use the beam dimensions $L := 11.82$ and $W := 3.94$, and we vary the initial perturbation angle $\theta$ among $1.43^{\circ}$, $2.86^{\circ}$, and $5.71^{\circ}$. Figure~\ref{fig:chap1.examples.propagation.cantilever.results} shows the results of the simulation for each of these three initial angles, where we have plotted the position of the crack tip at each time step: blue triangles correspond to $\theta = 1.43^{\circ}$; orange squares correspond to $\theta = 2.86^{\circ}$; and yellow triangles correspond to $\theta = 5.71^{\circ}$. Our simulation mesh has resolution $64 \times 20$ and our quadrature mesh has $3$ refinement levels. Our results are in good agreement with \cite{Belytschko99}.

\setlength{\figurewidth}{0.33\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/cantilever_setup}
\caption{The setup for a crack propagation example involving a beam with a crack at various initial perturbation angles $\theta$.}
\label{fig:chap1.examples.propagation.cantilever.setup}
\end{figure}

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/cantilever_paths}
\caption{The results of crack propagation in the cantilever beam example. We plot the position of the crack tip at each time step: blue triangles correspond to $\theta = 2.86^{\circ}$; and yellow triangles correspond to $\theta = 5.71^{\circ}$.}
 \label{fig:chap1.examples.propagation.cantilever.results}
\end{figure}

Figure~\ref{fig:chap1.examples.propagation.two_holes} depicts a more complicated scenario. The initial configuration (Figure~\ref{fig:chap1.examples.propagation.two_holes}\linebreak[0](top left)) is a square (with side lengths $1$) with two congruent holes (with radii $1/64$). We initialize the simulation with two cracks, one emerging from each hole and both at $45^{\circ}$ with respect to the horizontal such that the resulting geometry is rotationally symmetric (Figure~\ref{fig:chap1.examples.propagation.two_holes}(top right)). We subject this domain to constant traction boundary conditions on the left and right sides of the domain. Our simulation mesh has resolution $64 \times 64$ and our quadrature mesh has $2$ levels of refinement. The bottom row of Figure~\ref{fig:chap1.examples.propagation.two_holes} shows the simulation after $20$ time steps (for clarity, we removed the disconnected material region between the two cracks).

For the example in Figure~\ref{fig:chap1.examples.propagation.two_holes} and the next example, we use the mesh cutting algorithm from \cite{Sifakis07} to construct an embedding mesh for the domain. We start with a triangulation of a square domain and use the mesh cutting algorithm to excise from it the two circular holes, each represented as a segmentd curve. We thus effectively treat the embedded boundary of the domain around the circular holes as crack surface that has fully disconnected the discs from the square. This illustrates a general technique to mesh a domain which has the advantage that one may control the simulation mesh resolution independent of the geometry of the domain boundary. Further, since the mesh cutting algorithm naturally handles a crack tip inside a fully cut triangle, we can automatically handle the crack tip reaching the (embedded) boundary of the domain.

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/two_holes_frames}
\caption{Crack propagation in a square domain with holes; initial configuration (top row) and simulation after $20$ time steps (bottom row).}
\label{fig:chap1.examples.propagation.two_holes}
\end{figure}

Figure~\ref{fig:chap1.examples.propagation.bean} shows an example with more complicated domain and crack geometry. As in the previous example, we mesh the domain by excising a segmented curve from a triangulated rectangle (with $L = 2$ and $W = 1$) with resolution $128 \times 64$ (see Figure~\ref{fig:chap1.examples.propagation.bean.embedding}). We then introduce initial triple-junction cracks into the domain and apply displacement Dirichlet conditions on the left and right. Specifically, we assign a fixed displacement of $0.001$ to subset of the domain to the left of $x = -0.8$ or to the right of $x = +0.8$; these boundary conditions are visually evident in Figure~\ref{fig:chap1.examples.propagation.bean}, where the domain subsets on which we apply the fixed displacement have identically zero stress. We additionally apply traction boundary conditions at five other points along the boundary; these boundary conditions are also visually evident in Figure~\ref{fig:chap1.examples.propagation.bean} by the high stress they induce. Our quadrature mesh has $2$ levels of refinement. We simulate the propagation of the cracks over $20$ time steps. Note that as the cracks evolve they may join with other cracks, which we accomplish by procedurally merging cracks whose paths intersect. However, crack tips cannot branch (creating new junctions) with the propagation methd described in \S\ref{sec:chap1.propagation}.

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/bean_embedding}
\caption{An example application of the mesh cutting algorithm to mesh a domain. A triangulated rectangle overlays the domain (left), and the mesh cutting algorithm resolves the domain boundary against the background mesh. This yields two disconnected meshes, an interior one (right) and an exterior one, which we discard.}
\label{fig:chap1.examples.propagation.bean.embedding}
\end{figure}

\setlength{\figurewidth}{\textwidth}
\begin{figure}[htbp]
\centering
\includegraphics[width=\figurewidth]{partI/chapter1/figures/bean_frames}
\caption{Crack propagation simulation with complex geometry; initial configuration (top left), at $5$ time steps (top right), at $10$ time steps (bottom left), and at $25$ time steps (bottom right).}
\label{fig:chap1.examples.propagation.bean}
\end{figure}

\section{Discussion and Conclusion}

We presented an XFEM-based method for simulating crack propagation. This method employs the mesh cutting algorithm of Sifakis et al. \cite{Sifakis07} to automatically generate the extra degrees of freedom traditionally associated with XFEM Heaviside enrichment; these degrees of freedom enable the two sides of the crack surface to separate. We additionally described an integration scheme based on a subordinate and independently refined quadrature mesh to accurately evaluate integrals involving the nonlinear (and sometimes singular) basis functions. This in turn yields accurately computed stress intensity factors, which we use to propagate the crack. The generality of the mesh cutting algorithm allows us to accommodate complex crack and domain geometry, as shown in the examples. We also illustrated the accuracy of our method, and it compares favorably with the results from the literature.
